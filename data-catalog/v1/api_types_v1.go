// Copyright 2021 Confluent Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*
Confluent Data Catalog

REST API for the Data Catalog

API version: 1.0.0
Contact: data-governance@confluent.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v1

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

type TypesV1Api interface {

	/*
		CreateBusinessMetadataDefs Bulk Create Business Metadata Definitions

		[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

	Bulk create API for business metadata definitions.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return ApiCreateBusinessMetadataDefsRequest
	*/
	CreateBusinessMetadataDefs(ctx _context.Context) ApiCreateBusinessMetadataDefsRequest

	// CreateBusinessMetadataDefsExecute executes the request
	//  @return []BusinessMetadataDefResponse
	CreateBusinessMetadataDefsExecute(r ApiCreateBusinessMetadataDefsRequest) ([]BusinessMetadataDefResponse, *_nethttp.Response, error)

	/*
		CreateTagDefs Bulk Create Tag Definitions

		[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

	Bulk create API for tag definitions.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return ApiCreateTagDefsRequest
	*/
	CreateTagDefs(ctx _context.Context) ApiCreateTagDefsRequest

	// CreateTagDefsExecute executes the request
	//  @return []TagDefResponse
	CreateTagDefsExecute(r ApiCreateTagDefsRequest) ([]TagDefResponse, *_nethttp.Response, error)

	/*
		DeleteBusinessMetadataDef Delete Business Metadata Definition

		[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

	Delete API for business metadata definition identified by its name.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param bmName The name of the business metadata definition
		 @return ApiDeleteBusinessMetadataDefRequest
	*/
	DeleteBusinessMetadataDef(ctx _context.Context, bmName string) ApiDeleteBusinessMetadataDefRequest

	// DeleteBusinessMetadataDefExecute executes the request
	DeleteBusinessMetadataDefExecute(r ApiDeleteBusinessMetadataDefRequest) (*_nethttp.Response, error)

	/*
		DeleteTagDef Delete Tag Definition

		[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

	Delete API for tag definition identified by its name.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param tagName The name of the tag definition
		 @return ApiDeleteTagDefRequest
	*/
	DeleteTagDef(ctx _context.Context, tagName string) ApiDeleteTagDefRequest

	// DeleteTagDefExecute executes the request
	DeleteTagDefExecute(r ApiDeleteTagDefRequest) (*_nethttp.Response, error)

	/*
		GetAllBusinessMetadataDefs Bulk Read Business Metadata Definitions

		[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

	Bulk retrieval API for retrieving business metadata definitions.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return ApiGetAllBusinessMetadataDefsRequest
	*/
	GetAllBusinessMetadataDefs(ctx _context.Context) ApiGetAllBusinessMetadataDefsRequest

	// GetAllBusinessMetadataDefsExecute executes the request
	//  @return []BusinessMetadataDefResponse
	GetAllBusinessMetadataDefsExecute(r ApiGetAllBusinessMetadataDefsRequest) ([]BusinessMetadataDefResponse, *_nethttp.Response, error)

	/*
		GetAllTagDefs Bulk Read Tag Definitions

		[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

	Bulk retrieval API for retrieving tag definitions.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return ApiGetAllTagDefsRequest
	*/
	GetAllTagDefs(ctx _context.Context) ApiGetAllTagDefsRequest

	// GetAllTagDefsExecute executes the request
	//  @return []TagDefResponse
	GetAllTagDefsExecute(r ApiGetAllTagDefsRequest) ([]TagDefResponse, *_nethttp.Response, error)

	/*
		GetBusinessMetadataDefByName Read Business Metadata Definition

		[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

	Get the business metadata definition with the given name.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param bmName The name of the business metadata definition
		 @return ApiGetBusinessMetadataDefByNameRequest
	*/
	GetBusinessMetadataDefByName(ctx _context.Context, bmName string) ApiGetBusinessMetadataDefByNameRequest

	// GetBusinessMetadataDefByNameExecute executes the request
	//  @return BusinessMetadataDef
	GetBusinessMetadataDefByNameExecute(r ApiGetBusinessMetadataDefByNameRequest) (BusinessMetadataDef, *_nethttp.Response, error)

	/*
		GetTagDefByName Read Tag Definition

		[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

	Get the tag definition with the given name.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param tagName The name of the tag definiton
		 @return ApiGetTagDefByNameRequest
	*/
	GetTagDefByName(ctx _context.Context, tagName string) ApiGetTagDefByNameRequest

	// GetTagDefByNameExecute executes the request
	//  @return TagDef
	GetTagDefByNameExecute(r ApiGetTagDefByNameRequest) (TagDef, *_nethttp.Response, error)

	/*
		UpdateBusinessMetadataDefs Bulk Update Business Metadata Definitions

		[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

	Bulk update API for business metadata definitions.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return ApiUpdateBusinessMetadataDefsRequest
	*/
	UpdateBusinessMetadataDefs(ctx _context.Context) ApiUpdateBusinessMetadataDefsRequest

	// UpdateBusinessMetadataDefsExecute executes the request
	//  @return []BusinessMetadataDefResponse
	UpdateBusinessMetadataDefsExecute(r ApiUpdateBusinessMetadataDefsRequest) ([]BusinessMetadataDefResponse, *_nethttp.Response, error)

	/*
		UpdateTagDefs Bulk Update Tag Definitions

		[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

	Bulk update API for tag definitions.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return ApiUpdateTagDefsRequest
	*/
	UpdateTagDefs(ctx _context.Context) ApiUpdateTagDefsRequest

	// UpdateTagDefsExecute executes the request
	//  @return []TagDefResponse
	UpdateTagDefsExecute(r ApiUpdateTagDefsRequest) ([]TagDefResponse, *_nethttp.Response, error)
}

// TypesV1ApiService TypesV1Api service
type TypesV1ApiService service

type ApiCreateBusinessMetadataDefsRequest struct {
	ctx                 _context.Context
	ApiService          TypesV1Api
	businessMetadataDef *[]BusinessMetadataDef
}

// The business metadata definitions to create
func (r ApiCreateBusinessMetadataDefsRequest) BusinessMetadataDef(businessMetadataDef []BusinessMetadataDef) ApiCreateBusinessMetadataDefsRequest {
	r.businessMetadataDef = &businessMetadataDef
	return r
}

func (r ApiCreateBusinessMetadataDefsRequest) Execute() ([]BusinessMetadataDefResponse, *_nethttp.Response, error) {
	return r.ApiService.CreateBusinessMetadataDefsExecute(r)
}

/*
CreateBusinessMetadataDefs Bulk Create Business Metadata Definitions

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Bulk create API for business metadata definitions.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBusinessMetadataDefsRequest
*/
func (a *TypesV1ApiService) CreateBusinessMetadataDefs(ctx _context.Context) ApiCreateBusinessMetadataDefsRequest {
	return ApiCreateBusinessMetadataDefsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []BusinessMetadataDefResponse
func (a *TypesV1ApiService) CreateBusinessMetadataDefsExecute(r ApiCreateBusinessMetadataDefsRequest) ([]BusinessMetadataDefResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []BusinessMetadataDefResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TypesV1ApiService.CreateBusinessMetadataDefs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/types/businessmetadatadefs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.businessMetadataDef
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTagDefsRequest struct {
	ctx        _context.Context
	ApiService TypesV1Api
	tagDef     *[]TagDef
}

// The tag definitions to create
func (r ApiCreateTagDefsRequest) TagDef(tagDef []TagDef) ApiCreateTagDefsRequest {
	r.tagDef = &tagDef
	return r
}

func (r ApiCreateTagDefsRequest) Execute() ([]TagDefResponse, *_nethttp.Response, error) {
	return r.ApiService.CreateTagDefsExecute(r)
}

/*
CreateTagDefs Bulk Create Tag Definitions

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Bulk create API for tag definitions.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTagDefsRequest
*/
func (a *TypesV1ApiService) CreateTagDefs(ctx _context.Context) ApiCreateTagDefsRequest {
	return ApiCreateTagDefsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []TagDefResponse
func (a *TypesV1ApiService) CreateTagDefsExecute(r ApiCreateTagDefsRequest) ([]TagDefResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []TagDefResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TypesV1ApiService.CreateTagDefs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/types/tagdefs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tagDef
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBusinessMetadataDefRequest struct {
	ctx        _context.Context
	ApiService TypesV1Api
	bmName     string
}

func (r ApiDeleteBusinessMetadataDefRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteBusinessMetadataDefExecute(r)
}

/*
DeleteBusinessMetadataDef Delete Business Metadata Definition

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Delete API for business metadata definition identified by its name.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bmName The name of the business metadata definition
 @return ApiDeleteBusinessMetadataDefRequest
*/
func (a *TypesV1ApiService) DeleteBusinessMetadataDef(ctx _context.Context, bmName string) ApiDeleteBusinessMetadataDefRequest {
	return ApiDeleteBusinessMetadataDefRequest{
		ApiService: a,
		ctx:        ctx,
		bmName:     bmName,
	}
}

// Execute executes the request
func (a *TypesV1ApiService) DeleteBusinessMetadataDefExecute(r ApiDeleteBusinessMetadataDefRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TypesV1ApiService.DeleteBusinessMetadataDef")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/types/businessmetadatadefs/{bmName}"
	localVarPath = strings.Replace(localVarPath, "{"+"bmName"+"}", _neturl.PathEscape(parameterToString(r.bmName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteTagDefRequest struct {
	ctx        _context.Context
	ApiService TypesV1Api
	tagName    string
}

func (r ApiDeleteTagDefRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteTagDefExecute(r)
}

/*
DeleteTagDef Delete Tag Definition

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Delete API for tag definition identified by its name.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tagName The name of the tag definition
 @return ApiDeleteTagDefRequest
*/
func (a *TypesV1ApiService) DeleteTagDef(ctx _context.Context, tagName string) ApiDeleteTagDefRequest {
	return ApiDeleteTagDefRequest{
		ApiService: a,
		ctx:        ctx,
		tagName:    tagName,
	}
}

// Execute executes the request
func (a *TypesV1ApiService) DeleteTagDefExecute(r ApiDeleteTagDefRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TypesV1ApiService.DeleteTagDef")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/types/tagdefs/{tagName}"
	localVarPath = strings.Replace(localVarPath, "{"+"tagName"+"}", _neturl.PathEscape(parameterToString(r.tagName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAllBusinessMetadataDefsRequest struct {
	ctx        _context.Context
	ApiService TypesV1Api
	prefix     *string
}

// The prefix of a business metadata definition name
func (r ApiGetAllBusinessMetadataDefsRequest) Prefix(prefix string) ApiGetAllBusinessMetadataDefsRequest {
	r.prefix = &prefix
	return r
}

func (r ApiGetAllBusinessMetadataDefsRequest) Execute() ([]BusinessMetadataDefResponse, *_nethttp.Response, error) {
	return r.ApiService.GetAllBusinessMetadataDefsExecute(r)
}

/*
GetAllBusinessMetadataDefs Bulk Read Business Metadata Definitions

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Bulk retrieval API for retrieving business metadata definitions.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllBusinessMetadataDefsRequest
*/
func (a *TypesV1ApiService) GetAllBusinessMetadataDefs(ctx _context.Context) ApiGetAllBusinessMetadataDefsRequest {
	return ApiGetAllBusinessMetadataDefsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []BusinessMetadataDefResponse
func (a *TypesV1ApiService) GetAllBusinessMetadataDefsExecute(r ApiGetAllBusinessMetadataDefsRequest) ([]BusinessMetadataDefResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []BusinessMetadataDefResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TypesV1ApiService.GetAllBusinessMetadataDefs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/types/businessmetadatadefs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.prefix != nil {
		localVarQueryParams.Add("prefix", parameterToString(*r.prefix, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllTagDefsRequest struct {
	ctx        _context.Context
	ApiService TypesV1Api
	prefix     *string
}

// The prefix of a tag definition name
func (r ApiGetAllTagDefsRequest) Prefix(prefix string) ApiGetAllTagDefsRequest {
	r.prefix = &prefix
	return r
}

func (r ApiGetAllTagDefsRequest) Execute() ([]TagDefResponse, *_nethttp.Response, error) {
	return r.ApiService.GetAllTagDefsExecute(r)
}

/*
GetAllTagDefs Bulk Read Tag Definitions

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Bulk retrieval API for retrieving tag definitions.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllTagDefsRequest
*/
func (a *TypesV1ApiService) GetAllTagDefs(ctx _context.Context) ApiGetAllTagDefsRequest {
	return ApiGetAllTagDefsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []TagDefResponse
func (a *TypesV1ApiService) GetAllTagDefsExecute(r ApiGetAllTagDefsRequest) ([]TagDefResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []TagDefResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TypesV1ApiService.GetAllTagDefs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/types/tagdefs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.prefix != nil {
		localVarQueryParams.Add("prefix", parameterToString(*r.prefix, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBusinessMetadataDefByNameRequest struct {
	ctx        _context.Context
	ApiService TypesV1Api
	bmName     string
}

func (r ApiGetBusinessMetadataDefByNameRequest) Execute() (BusinessMetadataDef, *_nethttp.Response, error) {
	return r.ApiService.GetBusinessMetadataDefByNameExecute(r)
}

/*
GetBusinessMetadataDefByName Read Business Metadata Definition

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Get the business metadata definition with the given name.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bmName The name of the business metadata definition
 @return ApiGetBusinessMetadataDefByNameRequest
*/
func (a *TypesV1ApiService) GetBusinessMetadataDefByName(ctx _context.Context, bmName string) ApiGetBusinessMetadataDefByNameRequest {
	return ApiGetBusinessMetadataDefByNameRequest{
		ApiService: a,
		ctx:        ctx,
		bmName:     bmName,
	}
}

// Execute executes the request
//  @return BusinessMetadataDef
func (a *TypesV1ApiService) GetBusinessMetadataDefByNameExecute(r ApiGetBusinessMetadataDefByNameRequest) (BusinessMetadataDef, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BusinessMetadataDef
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TypesV1ApiService.GetBusinessMetadataDefByName")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/types/businessmetadatadefs/{bmName}"
	localVarPath = strings.Replace(localVarPath, "{"+"bmName"+"}", _neturl.PathEscape(parameterToString(r.bmName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTagDefByNameRequest struct {
	ctx        _context.Context
	ApiService TypesV1Api
	tagName    string
}

func (r ApiGetTagDefByNameRequest) Execute() (TagDef, *_nethttp.Response, error) {
	return r.ApiService.GetTagDefByNameExecute(r)
}

/*
GetTagDefByName Read Tag Definition

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Get the tag definition with the given name.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tagName The name of the tag definiton
 @return ApiGetTagDefByNameRequest
*/
func (a *TypesV1ApiService) GetTagDefByName(ctx _context.Context, tagName string) ApiGetTagDefByNameRequest {
	return ApiGetTagDefByNameRequest{
		ApiService: a,
		ctx:        ctx,
		tagName:    tagName,
	}
}

// Execute executes the request
//  @return TagDef
func (a *TypesV1ApiService) GetTagDefByNameExecute(r ApiGetTagDefByNameRequest) (TagDef, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TagDef
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TypesV1ApiService.GetTagDefByName")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/types/tagdefs/{tagName}"
	localVarPath = strings.Replace(localVarPath, "{"+"tagName"+"}", _neturl.PathEscape(parameterToString(r.tagName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateBusinessMetadataDefsRequest struct {
	ctx                 _context.Context
	ApiService          TypesV1Api
	businessMetadataDef *[]BusinessMetadataDef
}

// The business metadata definitions to update
func (r ApiUpdateBusinessMetadataDefsRequest) BusinessMetadataDef(businessMetadataDef []BusinessMetadataDef) ApiUpdateBusinessMetadataDefsRequest {
	r.businessMetadataDef = &businessMetadataDef
	return r
}

func (r ApiUpdateBusinessMetadataDefsRequest) Execute() ([]BusinessMetadataDefResponse, *_nethttp.Response, error) {
	return r.ApiService.UpdateBusinessMetadataDefsExecute(r)
}

/*
UpdateBusinessMetadataDefs Bulk Update Business Metadata Definitions

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Bulk update API for business metadata definitions.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateBusinessMetadataDefsRequest
*/
func (a *TypesV1ApiService) UpdateBusinessMetadataDefs(ctx _context.Context) ApiUpdateBusinessMetadataDefsRequest {
	return ApiUpdateBusinessMetadataDefsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []BusinessMetadataDefResponse
func (a *TypesV1ApiService) UpdateBusinessMetadataDefsExecute(r ApiUpdateBusinessMetadataDefsRequest) ([]BusinessMetadataDefResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []BusinessMetadataDefResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TypesV1ApiService.UpdateBusinessMetadataDefs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/types/businessmetadatadefs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.businessMetadataDef
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTagDefsRequest struct {
	ctx        _context.Context
	ApiService TypesV1Api
	tagDef     *[]TagDef
}

// The tag definitions to update
func (r ApiUpdateTagDefsRequest) TagDef(tagDef []TagDef) ApiUpdateTagDefsRequest {
	r.tagDef = &tagDef
	return r
}

func (r ApiUpdateTagDefsRequest) Execute() ([]TagDefResponse, *_nethttp.Response, error) {
	return r.ApiService.UpdateTagDefsExecute(r)
}

/*
UpdateTagDefs Bulk Update Tag Definitions

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Bulk update API for tag definitions.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateTagDefsRequest
*/
func (a *TypesV1ApiService) UpdateTagDefs(ctx _context.Context) ApiUpdateTagDefsRequest {
	return ApiUpdateTagDefsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []TagDefResponse
func (a *TypesV1ApiService) UpdateTagDefsExecute(r ApiUpdateTagDefsRequest) ([]TagDefResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []TagDefResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TypesV1ApiService.UpdateTagDefs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/types/tagdefs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tagDef
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
