/*
Apache Iceberg REST Catalog API

Defines the specification for the first version of the REST Catalog API. Implementations should ideally support both Iceberg table specs v1 and v2, with priority given to v2.

API version: 0.0.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v1

import (
	"bytes"
	"encoding/json"
	"fmt"
)

// checks if the LoadTableResult type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &LoadTableResult{}

// LoadTableResult Result used when a table is successfully loaded.   The table metadata JSON is returned in the `metadata` field. The corresponding file location of table metadata should be returned in the `metadata-location` field, unless the metadata is not yet committed. For example, a create transaction may return metadata that is staged but not committed. Clients can check whether metadata has changed by comparing metadata locations after the table has been created.   The `config` map returns table-specific configuration for the table's resources, including its HTTP client and FileIO. For example, config may contain a specific FileIO implementation class for the table depending on its underlying storage.   The following configurations should be respected by clients:  ## General Configurations  - `token`: Authorization bearer token to use for table requests if OAuth2 security is enabled  ## AWS Configurations  The following configurations should be respected when working with tables stored in AWS S3  - `client.region`: region to configure client for making requests to AWS  - `s3.access-key-id`: id for for credentials that provide access to the data in S3  - `s3.secret-access-key`: secret for credentials that provide access to data in S3  - `s3.session-token`: if present, this value should be used for as the session token  - `s3.remote-signing-enabled`: if `true` remote signing should be performed as described in the `s3-signer-open-api.yaml` specification
type LoadTableResult struct {
	// May be null if the table is staged as part of a transaction
	MetadataLocation *string            `json:"metadata-location,omitempty"`
	Metadata         TableMetadata      `json:"metadata"`
	Config           *map[string]string `json:"config,omitempty"`
}

type _LoadTableResult LoadTableResult

// NewLoadTableResult instantiates a new LoadTableResult object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewLoadTableResult(metadata TableMetadata) *LoadTableResult {
	this := LoadTableResult{}
	this.Metadata = metadata
	return &this
}

// NewLoadTableResultWithDefaults instantiates a new LoadTableResult object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewLoadTableResultWithDefaults() *LoadTableResult {
	this := LoadTableResult{}
	return &this
}

// GetMetadataLocation returns the MetadataLocation field value if set, zero value otherwise.
func (o *LoadTableResult) GetMetadataLocation() string {
	if o == nil || IsNil(o.MetadataLocation) {
		var ret string
		return ret
	}
	return *o.MetadataLocation
}

// GetMetadataLocationOk returns a tuple with the MetadataLocation field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *LoadTableResult) GetMetadataLocationOk() (*string, bool) {
	if o == nil || IsNil(o.MetadataLocation) {
		return nil, false
	}
	return o.MetadataLocation, true
}

// HasMetadataLocation returns a boolean if a field has been set.
func (o *LoadTableResult) HasMetadataLocation() bool {
	if o != nil && !IsNil(o.MetadataLocation) {
		return true
	}

	return false
}

// SetMetadataLocation gets a reference to the given string and assigns it to the MetadataLocation field.
func (o *LoadTableResult) SetMetadataLocation(v string) {
	o.MetadataLocation = &v
}

// GetMetadata returns the Metadata field value
func (o *LoadTableResult) GetMetadata() TableMetadata {
	if o == nil {
		var ret TableMetadata
		return ret
	}

	return o.Metadata
}

// GetMetadataOk returns a tuple with the Metadata field value
// and a boolean to check if the value has been set.
func (o *LoadTableResult) GetMetadataOk() (*TableMetadata, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Metadata, true
}

// SetMetadata sets field value
func (o *LoadTableResult) SetMetadata(v TableMetadata) {
	o.Metadata = v
}

// GetConfig returns the Config field value if set, zero value otherwise.
func (o *LoadTableResult) GetConfig() map[string]string {
	if o == nil || IsNil(o.Config) {
		var ret map[string]string
		return ret
	}
	return *o.Config
}

// GetConfigOk returns a tuple with the Config field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *LoadTableResult) GetConfigOk() (*map[string]string, bool) {
	if o == nil || IsNil(o.Config) {
		return nil, false
	}
	return o.Config, true
}

// HasConfig returns a boolean if a field has been set.
func (o *LoadTableResult) HasConfig() bool {
	if o != nil && !IsNil(o.Config) {
		return true
	}

	return false
}

// SetConfig gets a reference to the given map[string]string and assigns it to the Config field.
func (o *LoadTableResult) SetConfig(v map[string]string) {
	o.Config = &v
}

func (o LoadTableResult) MarshalJSON() ([]byte, error) {
	toSerialize, err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o LoadTableResult) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if !IsNil(o.MetadataLocation) {
		toSerialize["metadata-location"] = o.MetadataLocation
	}
	toSerialize["metadata"] = o.Metadata
	if !IsNil(o.Config) {
		toSerialize["config"] = o.Config
	}
	return toSerialize, nil
}

func (o *LoadTableResult) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"metadata",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err
	}

	for _, requiredProperty := range requiredProperties {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varLoadTableResult := _LoadTableResult{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varLoadTableResult)

	if err != nil {
		return err
	}

	*o = LoadTableResult(varLoadTableResult)

	return err
}

type NullableLoadTableResult struct {
	value *LoadTableResult
	isSet bool
}

func (v NullableLoadTableResult) Get() *LoadTableResult {
	return v.value
}

func (v *NullableLoadTableResult) Set(val *LoadTableResult) {
	v.value = val
	v.isSet = true
}

func (v NullableLoadTableResult) IsSet() bool {
	return v.isSet
}

func (v *NullableLoadTableResult) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableLoadTableResult(val *LoadTableResult) *NullableLoadTableResult {
	return &NullableLoadTableResult{value: val, isSet: true}
}

func (v NullableLoadTableResult) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableLoadTableResult) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
