/*
Apache Iceberg REST Catalog API

Defines the specification for the first version of the REST Catalog API. Implementations should ideally support both Iceberg table specs v1 and v2, with priority given to v2.

API version: 0.0.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v1

import (
	"encoding/json"
	"fmt"
)

// TokenType Token type identifier, from RFC 8693 Section 3  See https://datatracker.ietf.org/doc/html/rfc8693#section-3
type TokenType string

// List of TokenType
const (
	ACCESS_TOKEN  TokenType = "urn:ietf:params:oauth:token-type:access_token"
	REFRESH_TOKEN TokenType = "urn:ietf:params:oauth:token-type:refresh_token"
	ID_TOKEN      TokenType = "urn:ietf:params:oauth:token-type:id_token"
	SAML1         TokenType = "urn:ietf:params:oauth:token-type:saml1"
	SAML2         TokenType = "urn:ietf:params:oauth:token-type:saml2"
	JWT           TokenType = "urn:ietf:params:oauth:token-type:jwt"
)

// All allowed values of TokenType enum
var AllowedTokenTypeEnumValues = []TokenType{
	"urn:ietf:params:oauth:token-type:access_token",
	"urn:ietf:params:oauth:token-type:refresh_token",
	"urn:ietf:params:oauth:token-type:id_token",
	"urn:ietf:params:oauth:token-type:saml1",
	"urn:ietf:params:oauth:token-type:saml2",
	"urn:ietf:params:oauth:token-type:jwt",
}

func (v *TokenType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := TokenType(value)
	for _, existing := range AllowedTokenTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid TokenType", value)
}

// NewTokenTypeFromValue returns a pointer to a valid TokenType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewTokenTypeFromValue(v string) (*TokenType, error) {
	ev := TokenType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for TokenType: valid values are %v", v, AllowedTokenTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v TokenType) IsValid() bool {
	for _, existing := range AllowedTokenTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to TokenType value
func (v TokenType) Ptr() *TokenType {
	return &v
}

type NullableTokenType struct {
	value *TokenType
	isSet bool
}

func (v NullableTokenType) Get() *TokenType {
	return v.value
}

func (v *NullableTokenType) Set(val *TokenType) {
	v.value = val
	v.isSet = true
}

func (v NullableTokenType) IsSet() bool {
	return v.isSet
}

func (v *NullableTokenType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableTokenType(val *TokenType) *NullableTokenType {
	return &NullableTokenType{value: val, isSet: true}
}

func (v NullableTokenType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableTokenType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
