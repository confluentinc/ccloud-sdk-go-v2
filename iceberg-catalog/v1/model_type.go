/*
Apache Iceberg REST Catalog API

Defines the specification for the first version of the REST Catalog API. Implementations should ideally support both Iceberg table specs v1 and v2, with priority given to v2.

API version: 0.0.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v1

import (
	_ "bytes"
	"encoding/json"
	"fmt"
)

// Type - struct for Type
type Type struct {
	ListType   *ListType
	MapType    *MapType
	StructType *StructType
	String     *string
}

// ListTypeAsType is a convenience function that returns ListType wrapped in Type
func ListTypeAsType(v *ListType) Type {
	return Type{
		ListType: v,
	}
}

// MapTypeAsType is a convenience function that returns MapType wrapped in Type
func MapTypeAsType(v *MapType) Type {
	return Type{
		MapType: v,
	}
}

// StructTypeAsType is a convenience function that returns StructType wrapped in Type
func StructTypeAsType(v *StructType) Type {
	return Type{
		StructType: v,
	}
}

// stringAsType is a convenience function that returns string wrapped in Type
func StringAsType(v *string) Type {
	return Type{
		String: v,
	}
}

// Unmarshal JSON data into one of the pointers in the struct
func (dst *Type) UnmarshalJSON(data []byte) error {
	var err error
	match := 0
	// try to unmarshal data into ListType
	err = json.Unmarshal(data, &dst.ListType)
	if err == nil {
		jsonListType, _ := json.Marshal(dst.ListType)
		if string(jsonListType) == "{}" { // empty struct
			dst.ListType = nil
		} else {
			match++
		}
	} else {
		dst.ListType = nil
	}

	// try to unmarshal data into MapType
	err = json.Unmarshal(data, &dst.MapType)
	if err == nil {
		jsonMapType, _ := json.Marshal(dst.MapType)
		if string(jsonMapType) == "{}" { // empty struct
			dst.MapType = nil
		} else {
			match++
		}
	} else {
		dst.MapType = nil
	}

	// try to unmarshal data into StructType
	err = json.Unmarshal(data, &dst.StructType)
	if err == nil {
		jsonStructType, _ := json.Marshal(dst.StructType)
		if string(jsonStructType) == "{}" { // empty struct
			dst.StructType = nil
		} else {
			match++
		}
	} else {
		dst.StructType = nil
	}

	// try to unmarshal data into String
	err = json.Unmarshal(data, &dst.String)
	if err == nil {
		jsonstring, _ := json.Marshal(dst.String)
		if string(jsonstring) == "{}" { // empty struct
			dst.String = nil
		} else {
			match++
		}
	} else {
		dst.String = nil
	}

	if match > 1 { // more than 1 match
		// reset to nil
		dst.ListType = nil
		dst.MapType = nil
		dst.StructType = nil
		dst.String = nil

		return fmt.Errorf("data matches more than one schema in oneOf(Type)")
	} else if match == 1 {
		return nil // exactly one match
	} else { // no match
		return fmt.Errorf("data failed to match schemas in oneOf(Type)")
	}
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src Type) MarshalJSON() ([]byte, error) {
	if src.ListType != nil {
		return json.Marshal(&src.ListType)
	}

	if src.MapType != nil {
		return json.Marshal(&src.MapType)
	}

	if src.StructType != nil {
		return json.Marshal(&src.StructType)
	}

	if src.String != nil {
		return json.Marshal(&src.String)
	}

	return nil, nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *Type) GetActualInstance() interface{} {
	if obj == nil {
		return nil
	}
	if obj.ListType != nil {
		return obj.ListType
	}

	if obj.MapType != nil {
		return obj.MapType
	}

	if obj.StructType != nil {
		return obj.StructType
	}

	if obj.String != nil {
		return obj.String
	}

	// all schemas are nil
	return nil
}

type NullableType struct {
	value *Type
	isSet bool
}

func (v NullableType) Get() *Type {
	return v.value
}

func (v *NullableType) Set(val *Type) {
	v.value = val
	v.isSet = true
}

func (v NullableType) IsSet() bool {
	return v.isSet
}

func (v *NullableType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableType(val *Type) *NullableType {
	return &NullableType{value: val, isSet: true}
}

func (v NullableType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
