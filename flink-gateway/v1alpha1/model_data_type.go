// Copyright 2021 Confluent Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*
SQL API v1alpha1

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 0.0.1
Contact: flink-control-plane@confluent.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v1alpha1

import (
	"encoding/json"
	"fmt"
)

// DataType - struct for DataType
type DataType struct {
	ArrayType *ArrayType
	BigIntType *BigIntType
	BinaryType *BinaryType
	BooleanType *BooleanType
	CharType *CharType
	DateType *DateType
	DecimalType *DecimalType
	DoubleType *DoubleType
	FloatType *FloatType
	IntegerType *IntegerType
	IntervalDayTimeType *IntervalDayTimeType
	IntervalYearMonthType *IntervalYearMonthType
	MapType *MapType
	MultisetType *MultisetType
	RowType *RowType
	SmallIntType *SmallIntType
	TimeWithoutTimeZoneType *TimeWithoutTimeZoneType
	TimestampWithLocalTimeZoneType *TimestampWithLocalTimeZoneType
	TimestampWithTimeZoneType *TimestampWithTimeZoneType
	TimestampWithoutTimeZoneType *TimestampWithoutTimeZoneType
	TinyIntType *TinyIntType
	VarbinaryType *VarbinaryType
	VarcharType *VarcharType
}

// ArrayTypeAsDataType is a convenience function that returns ArrayType wrapped in DataType
func ArrayTypeAsDataType(v *ArrayType) DataType {
	return DataType{ ArrayType: v}
}

// BigIntTypeAsDataType is a convenience function that returns BigIntType wrapped in DataType
func BigIntTypeAsDataType(v *BigIntType) DataType {
	return DataType{ BigIntType: v}
}

// BinaryTypeAsDataType is a convenience function that returns BinaryType wrapped in DataType
func BinaryTypeAsDataType(v *BinaryType) DataType {
	return DataType{ BinaryType: v}
}

// BooleanTypeAsDataType is a convenience function that returns BooleanType wrapped in DataType
func BooleanTypeAsDataType(v *BooleanType) DataType {
	return DataType{ BooleanType: v}
}

// CharTypeAsDataType is a convenience function that returns CharType wrapped in DataType
func CharTypeAsDataType(v *CharType) DataType {
	return DataType{ CharType: v}
}

// DateTypeAsDataType is a convenience function that returns DateType wrapped in DataType
func DateTypeAsDataType(v *DateType) DataType {
	return DataType{ DateType: v}
}

// DecimalTypeAsDataType is a convenience function that returns DecimalType wrapped in DataType
func DecimalTypeAsDataType(v *DecimalType) DataType {
	return DataType{ DecimalType: v}
}

// DoubleTypeAsDataType is a convenience function that returns DoubleType wrapped in DataType
func DoubleTypeAsDataType(v *DoubleType) DataType {
	return DataType{ DoubleType: v}
}

// FloatTypeAsDataType is a convenience function that returns FloatType wrapped in DataType
func FloatTypeAsDataType(v *FloatType) DataType {
	return DataType{ FloatType: v}
}

// IntegerTypeAsDataType is a convenience function that returns IntegerType wrapped in DataType
func IntegerTypeAsDataType(v *IntegerType) DataType {
	return DataType{ IntegerType: v}
}

// IntervalDayTimeTypeAsDataType is a convenience function that returns IntervalDayTimeType wrapped in DataType
func IntervalDayTimeTypeAsDataType(v *IntervalDayTimeType) DataType {
	return DataType{ IntervalDayTimeType: v}
}

// IntervalYearMonthTypeAsDataType is a convenience function that returns IntervalYearMonthType wrapped in DataType
func IntervalYearMonthTypeAsDataType(v *IntervalYearMonthType) DataType {
	return DataType{ IntervalYearMonthType: v}
}

// MapTypeAsDataType is a convenience function that returns MapType wrapped in DataType
func MapTypeAsDataType(v *MapType) DataType {
	return DataType{ MapType: v}
}

// MultisetTypeAsDataType is a convenience function that returns MultisetType wrapped in DataType
func MultisetTypeAsDataType(v *MultisetType) DataType {
	return DataType{ MultisetType: v}
}

// RowTypeAsDataType is a convenience function that returns RowType wrapped in DataType
func RowTypeAsDataType(v *RowType) DataType {
	return DataType{ RowType: v}
}

// SmallIntTypeAsDataType is a convenience function that returns SmallIntType wrapped in DataType
func SmallIntTypeAsDataType(v *SmallIntType) DataType {
	return DataType{ SmallIntType: v}
}

// TimeWithoutTimeZoneTypeAsDataType is a convenience function that returns TimeWithoutTimeZoneType wrapped in DataType
func TimeWithoutTimeZoneTypeAsDataType(v *TimeWithoutTimeZoneType) DataType {
	return DataType{ TimeWithoutTimeZoneType: v}
}

// TimestampWithLocalTimeZoneTypeAsDataType is a convenience function that returns TimestampWithLocalTimeZoneType wrapped in DataType
func TimestampWithLocalTimeZoneTypeAsDataType(v *TimestampWithLocalTimeZoneType) DataType {
	return DataType{ TimestampWithLocalTimeZoneType: v}
}

// TimestampWithTimeZoneTypeAsDataType is a convenience function that returns TimestampWithTimeZoneType wrapped in DataType
func TimestampWithTimeZoneTypeAsDataType(v *TimestampWithTimeZoneType) DataType {
	return DataType{ TimestampWithTimeZoneType: v}
}

// TimestampWithoutTimeZoneTypeAsDataType is a convenience function that returns TimestampWithoutTimeZoneType wrapped in DataType
func TimestampWithoutTimeZoneTypeAsDataType(v *TimestampWithoutTimeZoneType) DataType {
	return DataType{ TimestampWithoutTimeZoneType: v}
}

// TinyIntTypeAsDataType is a convenience function that returns TinyIntType wrapped in DataType
func TinyIntTypeAsDataType(v *TinyIntType) DataType {
	return DataType{ TinyIntType: v}
}

// VarbinaryTypeAsDataType is a convenience function that returns VarbinaryType wrapped in DataType
func VarbinaryTypeAsDataType(v *VarbinaryType) DataType {
	return DataType{ VarbinaryType: v}
}

// VarcharTypeAsDataType is a convenience function that returns VarcharType wrapped in DataType
func VarcharTypeAsDataType(v *VarcharType) DataType {
	return DataType{ VarcharType: v}
}


// Unmarshal JSON data into one of the pointers in the struct
func (dst *DataType) UnmarshalJSON(data []byte) error {
	var err error
	match := 0
	// try to unmarshal data into ArrayType
	err = json.Unmarshal(data, &dst.ArrayType)
	if err == nil {
		jsonArrayType, _ := json.Marshal(dst.ArrayType)
		if string(jsonArrayType) == "{}" { // empty struct
			dst.ArrayType = nil
		} else {
			match++
		}
	} else {
		dst.ArrayType = nil
	}

	// try to unmarshal data into BigIntType
	err = json.Unmarshal(data, &dst.BigIntType)
	if err == nil {
		jsonBigIntType, _ := json.Marshal(dst.BigIntType)
		if string(jsonBigIntType) == "{}" { // empty struct
			dst.BigIntType = nil
		} else {
			match++
		}
	} else {
		dst.BigIntType = nil
	}

	// try to unmarshal data into BinaryType
	err = json.Unmarshal(data, &dst.BinaryType)
	if err == nil {
		jsonBinaryType, _ := json.Marshal(dst.BinaryType)
		if string(jsonBinaryType) == "{}" { // empty struct
			dst.BinaryType = nil
		} else {
			match++
		}
	} else {
		dst.BinaryType = nil
	}

	// try to unmarshal data into BooleanType
	err = json.Unmarshal(data, &dst.BooleanType)
	if err == nil {
		jsonBooleanType, _ := json.Marshal(dst.BooleanType)
		if string(jsonBooleanType) == "{}" { // empty struct
			dst.BooleanType = nil
		} else {
			match++
		}
	} else {
		dst.BooleanType = nil
	}

	// try to unmarshal data into CharType
	err = json.Unmarshal(data, &dst.CharType)
	if err == nil {
		jsonCharType, _ := json.Marshal(dst.CharType)
		if string(jsonCharType) == "{}" { // empty struct
			dst.CharType = nil
		} else {
			match++
		}
	} else {
		dst.CharType = nil
	}

	// try to unmarshal data into DateType
	err = json.Unmarshal(data, &dst.DateType)
	if err == nil {
		jsonDateType, _ := json.Marshal(dst.DateType)
		if string(jsonDateType) == "{}" { // empty struct
			dst.DateType = nil
		} else {
			match++
		}
	} else {
		dst.DateType = nil
	}

	// try to unmarshal data into DecimalType
	err = json.Unmarshal(data, &dst.DecimalType)
	if err == nil {
		jsonDecimalType, _ := json.Marshal(dst.DecimalType)
		if string(jsonDecimalType) == "{}" { // empty struct
			dst.DecimalType = nil
		} else {
			match++
		}
	} else {
		dst.DecimalType = nil
	}

	// try to unmarshal data into DoubleType
	err = json.Unmarshal(data, &dst.DoubleType)
	if err == nil {
		jsonDoubleType, _ := json.Marshal(dst.DoubleType)
		if string(jsonDoubleType) == "{}" { // empty struct
			dst.DoubleType = nil
		} else {
			match++
		}
	} else {
		dst.DoubleType = nil
	}

	// try to unmarshal data into FloatType
	err = json.Unmarshal(data, &dst.FloatType)
	if err == nil {
		jsonFloatType, _ := json.Marshal(dst.FloatType)
		if string(jsonFloatType) == "{}" { // empty struct
			dst.FloatType = nil
		} else {
			match++
		}
	} else {
		dst.FloatType = nil
	}

	// try to unmarshal data into IntegerType
	err = json.Unmarshal(data, &dst.IntegerType)
	if err == nil {
		jsonIntegerType, _ := json.Marshal(dst.IntegerType)
		if string(jsonIntegerType) == "{}" { // empty struct
			dst.IntegerType = nil
		} else {
			match++
		}
	} else {
		dst.IntegerType = nil
	}

	// try to unmarshal data into IntervalDayTimeType
	err = json.Unmarshal(data, &dst.IntervalDayTimeType)
	if err == nil {
		jsonIntervalDayTimeType, _ := json.Marshal(dst.IntervalDayTimeType)
		if string(jsonIntervalDayTimeType) == "{}" { // empty struct
			dst.IntervalDayTimeType = nil
		} else {
			match++
		}
	} else {
		dst.IntervalDayTimeType = nil
	}

	// try to unmarshal data into IntervalYearMonthType
	err = json.Unmarshal(data, &dst.IntervalYearMonthType)
	if err == nil {
		jsonIntervalYearMonthType, _ := json.Marshal(dst.IntervalYearMonthType)
		if string(jsonIntervalYearMonthType) == "{}" { // empty struct
			dst.IntervalYearMonthType = nil
		} else {
			match++
		}
	} else {
		dst.IntervalYearMonthType = nil
	}

	// try to unmarshal data into MapType
	err = json.Unmarshal(data, &dst.MapType)
	if err == nil {
		jsonMapType, _ := json.Marshal(dst.MapType)
		if string(jsonMapType) == "{}" { // empty struct
			dst.MapType = nil
		} else {
			match++
		}
	} else {
		dst.MapType = nil
	}

	// try to unmarshal data into MultisetType
	err = json.Unmarshal(data, &dst.MultisetType)
	if err == nil {
		jsonMultisetType, _ := json.Marshal(dst.MultisetType)
		if string(jsonMultisetType) == "{}" { // empty struct
			dst.MultisetType = nil
		} else {
			match++
		}
	} else {
		dst.MultisetType = nil
	}

	// try to unmarshal data into RowType
	err = json.Unmarshal(data, &dst.RowType)
	if err == nil {
		jsonRowType, _ := json.Marshal(dst.RowType)
		if string(jsonRowType) == "{}" { // empty struct
			dst.RowType = nil
		} else {
			match++
		}
	} else {
		dst.RowType = nil
	}

	// try to unmarshal data into SmallIntType
	err = json.Unmarshal(data, &dst.SmallIntType)
	if err == nil {
		jsonSmallIntType, _ := json.Marshal(dst.SmallIntType)
		if string(jsonSmallIntType) == "{}" { // empty struct
			dst.SmallIntType = nil
		} else {
			match++
		}
	} else {
		dst.SmallIntType = nil
	}

	// try to unmarshal data into TimeWithoutTimeZoneType
	err = json.Unmarshal(data, &dst.TimeWithoutTimeZoneType)
	if err == nil {
		jsonTimeWithoutTimeZoneType, _ := json.Marshal(dst.TimeWithoutTimeZoneType)
		if string(jsonTimeWithoutTimeZoneType) == "{}" { // empty struct
			dst.TimeWithoutTimeZoneType = nil
		} else {
			match++
		}
	} else {
		dst.TimeWithoutTimeZoneType = nil
	}

	// try to unmarshal data into TimestampWithLocalTimeZoneType
	err = json.Unmarshal(data, &dst.TimestampWithLocalTimeZoneType)
	if err == nil {
		jsonTimestampWithLocalTimeZoneType, _ := json.Marshal(dst.TimestampWithLocalTimeZoneType)
		if string(jsonTimestampWithLocalTimeZoneType) == "{}" { // empty struct
			dst.TimestampWithLocalTimeZoneType = nil
		} else {
			match++
		}
	} else {
		dst.TimestampWithLocalTimeZoneType = nil
	}

	// try to unmarshal data into TimestampWithTimeZoneType
	err = json.Unmarshal(data, &dst.TimestampWithTimeZoneType)
	if err == nil {
		jsonTimestampWithTimeZoneType, _ := json.Marshal(dst.TimestampWithTimeZoneType)
		if string(jsonTimestampWithTimeZoneType) == "{}" { // empty struct
			dst.TimestampWithTimeZoneType = nil
		} else {
			match++
		}
	} else {
		dst.TimestampWithTimeZoneType = nil
	}

	// try to unmarshal data into TimestampWithoutTimeZoneType
	err = json.Unmarshal(data, &dst.TimestampWithoutTimeZoneType)
	if err == nil {
		jsonTimestampWithoutTimeZoneType, _ := json.Marshal(dst.TimestampWithoutTimeZoneType)
		if string(jsonTimestampWithoutTimeZoneType) == "{}" { // empty struct
			dst.TimestampWithoutTimeZoneType = nil
		} else {
			match++
		}
	} else {
		dst.TimestampWithoutTimeZoneType = nil
	}

	// try to unmarshal data into TinyIntType
	err = json.Unmarshal(data, &dst.TinyIntType)
	if err == nil {
		jsonTinyIntType, _ := json.Marshal(dst.TinyIntType)
		if string(jsonTinyIntType) == "{}" { // empty struct
			dst.TinyIntType = nil
		} else {
			match++
		}
	} else {
		dst.TinyIntType = nil
	}

	// try to unmarshal data into VarbinaryType
	err = json.Unmarshal(data, &dst.VarbinaryType)
	if err == nil {
		jsonVarbinaryType, _ := json.Marshal(dst.VarbinaryType)
		if string(jsonVarbinaryType) == "{}" { // empty struct
			dst.VarbinaryType = nil
		} else {
			match++
		}
	} else {
		dst.VarbinaryType = nil
	}

	// try to unmarshal data into VarcharType
	err = json.Unmarshal(data, &dst.VarcharType)
	if err == nil {
		jsonVarcharType, _ := json.Marshal(dst.VarcharType)
		if string(jsonVarcharType) == "{}" { // empty struct
			dst.VarcharType = nil
		} else {
			match++
		}
	} else {
		dst.VarcharType = nil
	}

	if match > 1 { // more than 1 match
		// reset to nil
		dst.ArrayType = nil
		dst.BigIntType = nil
		dst.BinaryType = nil
		dst.BooleanType = nil
		dst.CharType = nil
		dst.DateType = nil
		dst.DecimalType = nil
		dst.DoubleType = nil
		dst.FloatType = nil
		dst.IntegerType = nil
		dst.IntervalDayTimeType = nil
		dst.IntervalYearMonthType = nil
		dst.MapType = nil
		dst.MultisetType = nil
		dst.RowType = nil
		dst.SmallIntType = nil
		dst.TimeWithoutTimeZoneType = nil
		dst.TimestampWithLocalTimeZoneType = nil
		dst.TimestampWithTimeZoneType = nil
		dst.TimestampWithoutTimeZoneType = nil
		dst.TinyIntType = nil
		dst.VarbinaryType = nil
		dst.VarcharType = nil

		return fmt.Errorf("Data matches more than one schema in oneOf(DataType)")
	} else if match == 1 {
		return nil // exactly one match
	} else { // no match
		return fmt.Errorf("Data failed to match schemas in oneOf(DataType)")
	}
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src DataType) MarshalJSON() ([]byte, error) {
	if src.ArrayType != nil {
		return json.Marshal(&src.ArrayType)
	}

	if src.BigIntType != nil {
		return json.Marshal(&src.BigIntType)
	}

	if src.BinaryType != nil {
		return json.Marshal(&src.BinaryType)
	}

	if src.BooleanType != nil {
		return json.Marshal(&src.BooleanType)
	}

	if src.CharType != nil {
		return json.Marshal(&src.CharType)
	}

	if src.DateType != nil {
		return json.Marshal(&src.DateType)
	}

	if src.DecimalType != nil {
		return json.Marshal(&src.DecimalType)
	}

	if src.DoubleType != nil {
		return json.Marshal(&src.DoubleType)
	}

	if src.FloatType != nil {
		return json.Marshal(&src.FloatType)
	}

	if src.IntegerType != nil {
		return json.Marshal(&src.IntegerType)
	}

	if src.IntervalDayTimeType != nil {
		return json.Marshal(&src.IntervalDayTimeType)
	}

	if src.IntervalYearMonthType != nil {
		return json.Marshal(&src.IntervalYearMonthType)
	}

	if src.MapType != nil {
		return json.Marshal(&src.MapType)
	}

	if src.MultisetType != nil {
		return json.Marshal(&src.MultisetType)
	}

	if src.RowType != nil {
		return json.Marshal(&src.RowType)
	}

	if src.SmallIntType != nil {
		return json.Marshal(&src.SmallIntType)
	}

	if src.TimeWithoutTimeZoneType != nil {
		return json.Marshal(&src.TimeWithoutTimeZoneType)
	}

	if src.TimestampWithLocalTimeZoneType != nil {
		return json.Marshal(&src.TimestampWithLocalTimeZoneType)
	}

	if src.TimestampWithTimeZoneType != nil {
		return json.Marshal(&src.TimestampWithTimeZoneType)
	}

	if src.TimestampWithoutTimeZoneType != nil {
		return json.Marshal(&src.TimestampWithoutTimeZoneType)
	}

	if src.TinyIntType != nil {
		return json.Marshal(&src.TinyIntType)
	}

	if src.VarbinaryType != nil {
		return json.Marshal(&src.VarbinaryType)
	}

	if src.VarcharType != nil {
		return json.Marshal(&src.VarcharType)
	}

	return nil, nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *DataType) GetActualInstance() (interface{}) {
	if obj.ArrayType != nil {
		return obj.ArrayType
	}

	if obj.BigIntType != nil {
		return obj.BigIntType
	}

	if obj.BinaryType != nil {
		return obj.BinaryType
	}

	if obj.BooleanType != nil {
		return obj.BooleanType
	}

	if obj.CharType != nil {
		return obj.CharType
	}

	if obj.DateType != nil {
		return obj.DateType
	}

	if obj.DecimalType != nil {
		return obj.DecimalType
	}

	if obj.DoubleType != nil {
		return obj.DoubleType
	}

	if obj.FloatType != nil {
		return obj.FloatType
	}

	if obj.IntegerType != nil {
		return obj.IntegerType
	}

	if obj.IntervalDayTimeType != nil {
		return obj.IntervalDayTimeType
	}

	if obj.IntervalYearMonthType != nil {
		return obj.IntervalYearMonthType
	}

	if obj.MapType != nil {
		return obj.MapType
	}

	if obj.MultisetType != nil {
		return obj.MultisetType
	}

	if obj.RowType != nil {
		return obj.RowType
	}

	if obj.SmallIntType != nil {
		return obj.SmallIntType
	}

	if obj.TimeWithoutTimeZoneType != nil {
		return obj.TimeWithoutTimeZoneType
	}

	if obj.TimestampWithLocalTimeZoneType != nil {
		return obj.TimestampWithLocalTimeZoneType
	}

	if obj.TimestampWithTimeZoneType != nil {
		return obj.TimestampWithTimeZoneType
	}

	if obj.TimestampWithoutTimeZoneType != nil {
		return obj.TimestampWithoutTimeZoneType
	}

	if obj.TinyIntType != nil {
		return obj.TinyIntType
	}

	if obj.VarbinaryType != nil {
		return obj.VarbinaryType
	}

	if obj.VarcharType != nil {
		return obj.VarcharType
	}

	// all schemas are nil
	return nil
}

type NullableDataType struct {
	value *DataType
	isSet bool
}

func (v NullableDataType) Get() *DataType {
	return v.value
}

func (v *NullableDataType) Set(val *DataType) {
	v.value = val
	v.isSet = true
}

func (v NullableDataType) IsSet() bool {
	return v.isSet
}

func (v *NullableDataType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableDataType(val *DataType) *NullableDataType {
	return &NullableDataType{value: val, isSet: true}
}

func (v NullableDataType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableDataType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


