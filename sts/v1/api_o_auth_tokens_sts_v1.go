// Copyright 2021 Confluent Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*
Security Token Service API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 0.0.1-alpha0
Contact: paas-team@confluent.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v1

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

type OAuthTokensStsV1Api interface {

	/*
	ExchangeStsV1OauthToken Exchange an OAuth Token

	[![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Use this operation to exchange an access token (JWT) issued by an external identity provider for
an access token (JWT) issued by Confluent.This enables the use of external identities
to access Confluent Cloud APIs.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiExchangeStsV1OauthTokenRequest
	*/
	ExchangeStsV1OauthToken(ctx _context.Context) ApiExchangeStsV1OauthTokenRequest

	// ExchangeStsV1OauthTokenExecute executes the request
	//  @return StsV1TokenExchangeReply
	ExchangeStsV1OauthTokenExecute(r ApiExchangeStsV1OauthTokenRequest) (StsV1TokenExchangeReply, *_nethttp.Response, error)
}

// OAuthTokensStsV1ApiService OAuthTokensStsV1Api service
type OAuthTokensStsV1ApiService service

type ApiExchangeStsV1OauthTokenRequest struct {
	ctx _context.Context
	ApiService OAuthTokensStsV1Api
	apiVersion *string
	kind *string
	id *string
	grantType *string
	subjectToken *string
	identityPoolId *string
	subjectTokenType *string
	requestedTokenType *string
	expiresIn *int32
}

// APIVersion defines the schema version of this representation of a resource.
func (r ApiExchangeStsV1OauthTokenRequest) ApiVersion(apiVersion string) ApiExchangeStsV1OauthTokenRequest {
	r.apiVersion = &apiVersion
	return r
}
// Kind defines the object this REST resource represents.
func (r ApiExchangeStsV1OauthTokenRequest) Kind(kind string) ApiExchangeStsV1OauthTokenRequest {
	r.kind = &kind
	return r
}
// ID is the \\\&quot;natural identifier\\\&quot; for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted (\\\&quot;time\\\&quot;); however, it may collide with IDs for other object &#x60;kinds&#x60; or objects of the same &#x60;kind&#x60; within a different scope/namespace (\\\&quot;space\\\&quot;).
func (r ApiExchangeStsV1OauthTokenRequest) Id(id string) ApiExchangeStsV1OauthTokenRequest {
	r.id = &id
	return r
}
// The grant type. Must be urn:ietf:params:oauth:grant-type:token-exchange, which indicates a token exchange.
func (r ApiExchangeStsV1OauthTokenRequest) GrantType(grantType string) ApiExchangeStsV1OauthTokenRequest {
	r.grantType = &grantType
	return r
}
// Confluent Cloud only accepts JSON Web Token (JWT) access tokens from customer identity provider
func (r ApiExchangeStsV1OauthTokenRequest) SubjectToken(subjectToken string) ApiExchangeStsV1OauthTokenRequest {
	r.subjectToken = &subjectToken
	return r
}
// Identity pool is a group of external identities that are assigned a certain level of access based on policy 
func (r ApiExchangeStsV1OauthTokenRequest) IdentityPoolId(identityPoolId string) ApiExchangeStsV1OauthTokenRequest {
	r.identityPoolId = &identityPoolId
	return r
}
// An identifier for the type of requested security token. Supported values is urn:ietf:params:oauth:token-type:jwt. 
func (r ApiExchangeStsV1OauthTokenRequest) SubjectTokenType(subjectTokenType string) ApiExchangeStsV1OauthTokenRequest {
	r.subjectTokenType = &subjectTokenType
	return r
}
// An identifier for the type of requested security token. Supported values is urn:ietf:params:oauth:token-type:access_token. 
func (r ApiExchangeStsV1OauthTokenRequest) RequestedTokenType(requestedTokenType string) ApiExchangeStsV1OauthTokenRequest {
	r.requestedTokenType = &requestedTokenType
	return r
}
// The amount of time, in seconds, between the time when the access token was issued and the time when the access token will expire 
func (r ApiExchangeStsV1OauthTokenRequest) ExpiresIn(expiresIn int32) ApiExchangeStsV1OauthTokenRequest {
	r.expiresIn = &expiresIn
	return r
}

func (r ApiExchangeStsV1OauthTokenRequest) Execute() (StsV1TokenExchangeReply, *_nethttp.Response, error) {
	return r.ApiService.ExchangeStsV1OauthTokenExecute(r)
}

/*
ExchangeStsV1OauthToken Exchange an OAuth Token

[![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Use this operation to exchange an access token (JWT) issued by an external identity provider for
an access token (JWT) issued by Confluent.This enables the use of external identities
to access Confluent Cloud APIs.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExchangeStsV1OauthTokenRequest
*/
func (a *OAuthTokensStsV1ApiService) ExchangeStsV1OauthToken(ctx _context.Context) ApiExchangeStsV1OauthTokenRequest {
	return ApiExchangeStsV1OauthTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StsV1TokenExchangeReply
func (a *OAuthTokensStsV1ApiService) ExchangeStsV1OauthTokenExecute(r ApiExchangeStsV1OauthTokenRequest) (StsV1TokenExchangeReply, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  StsV1TokenExchangeReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OAuthTokensStsV1ApiService.ExchangeStsV1OauthToken")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sts/v1/oauth2/token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.apiVersion != nil {
		localVarFormParams.Add("api_version", parameterToString(*r.apiVersion, ""))
	}
	if r.kind != nil {
		localVarFormParams.Add("kind", parameterToString(*r.kind, ""))
	}
	if r.id != nil {
		localVarFormParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.grantType != nil {
		localVarFormParams.Add("grant_type", parameterToString(*r.grantType, ""))
	}
	if r.subjectToken != nil {
		localVarFormParams.Add("subject_token", parameterToString(*r.subjectToken, ""))
	}
	if r.identityPoolId != nil {
		localVarFormParams.Add("identity_pool_id", parameterToString(*r.identityPoolId, ""))
	}
	if r.subjectTokenType != nil {
		localVarFormParams.Add("subject_token_type", parameterToString(*r.subjectTokenType, ""))
	}
	if r.requestedTokenType != nil {
		localVarFormParams.Add("requested_token_type", parameterToString(*r.requestedTokenType, ""))
	}
	if r.expiresIn != nil {
		localVarFormParams.Add("expires_in", parameterToString(*r.expiresIn, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Failure
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Failure
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
