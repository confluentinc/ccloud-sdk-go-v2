// Copyright 2021 Confluent Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*
REST Admin API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 3.0.0
Contact: kafka-clients-proxy-team@confluent.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v3

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

type ConfigsV3Api interface {

	/*
	DeleteKafkaV3ClusterConfig Reset Cluster Config

	[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Resets the configuration parameter specified by ``name`` to its
default value.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param clusterId The Kafka cluster ID.
	 @param name The configuration parameter name.
	 @return ApiDeleteKafkaV3ClusterConfigRequest
	*/
	DeleteKafkaV3ClusterConfig(ctx _context.Context, clusterId string, name string) ApiDeleteKafkaV3ClusterConfigRequest

	// DeleteKafkaV3ClusterConfigExecute executes the request
	DeleteKafkaV3ClusterConfigExecute(r ApiDeleteKafkaV3ClusterConfigRequest) (*_nethttp.Response, error)

	/*
	DeleteKafkaV3TopicConfig Reset Topic Config

	[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Resets the config with given `name` to its default value.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param clusterId The Kafka cluster ID.
	 @param topicName The topic name.
	 @param name The configuration parameter name.
	 @return ApiDeleteKafkaV3TopicConfigRequest
	*/
	DeleteKafkaV3TopicConfig(ctx _context.Context, clusterId string, topicName string, name string) ApiDeleteKafkaV3TopicConfigRequest

	// DeleteKafkaV3TopicConfigExecute executes the request
	DeleteKafkaV3TopicConfigExecute(r ApiDeleteKafkaV3TopicConfigRequest) (*_nethttp.Response, error)

	/*
	GetKafkaV3ClusterConfig Get Cluster Config

	[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Returns the configuration parameter specified by ``name``.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param clusterId The Kafka cluster ID.
	 @param name The configuration parameter name.
	 @return ApiGetKafkaV3ClusterConfigRequest
	*/
	GetKafkaV3ClusterConfig(ctx _context.Context, clusterId string, name string) ApiGetKafkaV3ClusterConfigRequest

	// GetKafkaV3ClusterConfigExecute executes the request
	//  @return ClusterConfigData
	GetKafkaV3ClusterConfigExecute(r ApiGetKafkaV3ClusterConfigRequest) (ClusterConfigData, *_nethttp.Response, error)

	/*
	GetKafkaV3TopicConfig Get Topic Config

	[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Return the config with the given `name`.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param clusterId The Kafka cluster ID.
	 @param topicName The topic name.
	 @param name The configuration parameter name.
	 @return ApiGetKafkaV3TopicConfigRequest
	*/
	GetKafkaV3TopicConfig(ctx _context.Context, clusterId string, topicName string, name string) ApiGetKafkaV3TopicConfigRequest

	// GetKafkaV3TopicConfigExecute executes the request
	//  @return TopicConfigData
	GetKafkaV3TopicConfigExecute(r ApiGetKafkaV3TopicConfigRequest) (TopicConfigData, *_nethttp.Response, error)

	/*
	ListKafkaV3AllTopicConfigs Get All Topic Configs

	[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Returns all topic configurations for topics hosted by the specified
cluster.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param clusterId The Kafka cluster ID.
	 @return ApiListKafkaV3AllTopicConfigsRequest
	*/
	ListKafkaV3AllTopicConfigs(ctx _context.Context, clusterId string) ApiListKafkaV3AllTopicConfigsRequest

	// ListKafkaV3AllTopicConfigsExecute executes the request
	//  @return TopicConfigDataList
	ListKafkaV3AllTopicConfigsExecute(r ApiListKafkaV3AllTopicConfigsRequest) (TopicConfigDataList, *_nethttp.Response, error)

	/*
	ListKafkaV3ClusterConfigs List Cluster Configs

	[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Returns a list of configuration parameters for the specified Kafka
cluster.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param clusterId The Kafka cluster ID.
	 @return ApiListKafkaV3ClusterConfigsRequest
	*/
	ListKafkaV3ClusterConfigs(ctx _context.Context, clusterId string) ApiListKafkaV3ClusterConfigsRequest

	// ListKafkaV3ClusterConfigsExecute executes the request
	//  @return ClusterConfigDataList
	ListKafkaV3ClusterConfigsExecute(r ApiListKafkaV3ClusterConfigsRequest) (ClusterConfigDataList, *_nethttp.Response, error)

	/*
	ListKafkaV3TopicConfigs List Topic Configs

	[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Return the list of configs that belong to the specified topic.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param clusterId The Kafka cluster ID.
	 @param topicName The topic name.
	 @return ApiListKafkaV3TopicConfigsRequest
	*/
	ListKafkaV3TopicConfigs(ctx _context.Context, clusterId string, topicName string) ApiListKafkaV3TopicConfigsRequest

	// ListKafkaV3TopicConfigsExecute executes the request
	//  @return TopicConfigDataList
	ListKafkaV3TopicConfigsExecute(r ApiListKafkaV3TopicConfigsRequest) (TopicConfigDataList, *_nethttp.Response, error)

	/*
	UpdateKafkaV3ClusterConfig Update Cluster Config

	[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Updates the configuration parameter specified by ``name``.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param clusterId The Kafka cluster ID.
	 @param name The configuration parameter name.
	 @return ApiUpdateKafkaV3ClusterConfigRequest
	*/
	UpdateKafkaV3ClusterConfig(ctx _context.Context, clusterId string, name string) ApiUpdateKafkaV3ClusterConfigRequest

	// UpdateKafkaV3ClusterConfigExecute executes the request
	UpdateKafkaV3ClusterConfigExecute(r ApiUpdateKafkaV3ClusterConfigRequest) (*_nethttp.Response, error)

	/*
	UpdateKafkaV3ClusterConfigs Batch Alter Cluster Configs

	[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Updates or deletes a set of Kafka cluster configuration parameters.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param clusterId The Kafka cluster ID.
	 @return ApiUpdateKafkaV3ClusterConfigsRequest
	*/
	UpdateKafkaV3ClusterConfigs(ctx _context.Context, clusterId string) ApiUpdateKafkaV3ClusterConfigsRequest

	// UpdateKafkaV3ClusterConfigsExecute executes the request
	UpdateKafkaV3ClusterConfigsExecute(r ApiUpdateKafkaV3ClusterConfigsRequest) (*_nethttp.Response, error)

	/*
	UpdateKafkaV3TopicConfig Update Topic Config

	[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Updates the config with given `name`.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param clusterId The Kafka cluster ID.
	 @param topicName The topic name.
	 @param name The configuration parameter name.
	 @return ApiUpdateKafkaV3TopicConfigRequest
	*/
	UpdateKafkaV3TopicConfig(ctx _context.Context, clusterId string, topicName string, name string) ApiUpdateKafkaV3TopicConfigRequest

	// UpdateKafkaV3TopicConfigExecute executes the request
	UpdateKafkaV3TopicConfigExecute(r ApiUpdateKafkaV3TopicConfigRequest) (*_nethttp.Response, error)

	/*
	UpdateKafkaV3TopicConfigBatch Batch Alter Topic Configs

	[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Updates or deletes a set of topic configs.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param clusterId The Kafka cluster ID.
	 @param topicName The topic name.
	 @return ApiUpdateKafkaV3TopicConfigBatchRequest
	*/
	UpdateKafkaV3TopicConfigBatch(ctx _context.Context, clusterId string, topicName string) ApiUpdateKafkaV3TopicConfigBatchRequest

	// UpdateKafkaV3TopicConfigBatchExecute executes the request
	UpdateKafkaV3TopicConfigBatchExecute(r ApiUpdateKafkaV3TopicConfigBatchRequest) (*_nethttp.Response, error)
}

// ConfigsV3ApiService ConfigsV3Api service
type ConfigsV3ApiService service

type ApiDeleteKafkaV3ClusterConfigRequest struct {
	ctx _context.Context
	ApiService ConfigsV3Api
	clusterId string
	name string
}


func (r ApiDeleteKafkaV3ClusterConfigRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKafkaV3ClusterConfigExecute(r)
}

/*
DeleteKafkaV3ClusterConfig Reset Cluster Config

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Resets the configuration parameter specified by ``name`` to its
default value.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId The Kafka cluster ID.
 @param name The configuration parameter name.
 @return ApiDeleteKafkaV3ClusterConfigRequest
*/
func (a *ConfigsV3ApiService) DeleteKafkaV3ClusterConfig(ctx _context.Context, clusterId string, name string) ApiDeleteKafkaV3ClusterConfigRequest {
	return ApiDeleteKafkaV3ClusterConfigRequest{
		ApiService: a,
		ctx: ctx,
		clusterId: clusterId,
		name: name,
	}
}

// Execute executes the request
func (a *ConfigsV3ApiService) DeleteKafkaV3ClusterConfigExecute(r ApiDeleteKafkaV3ClusterConfigRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigsV3ApiService.DeleteKafkaV3ClusterConfig")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafka/v3/clusters/{cluster_id}/broker-configs/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(r.clusterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteKafkaV3TopicConfigRequest struct {
	ctx _context.Context
	ApiService ConfigsV3Api
	clusterId string
	topicName string
	name string
}


func (r ApiDeleteKafkaV3TopicConfigRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKafkaV3TopicConfigExecute(r)
}

/*
DeleteKafkaV3TopicConfig Reset Topic Config

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Resets the config with given `name` to its default value.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId The Kafka cluster ID.
 @param topicName The topic name.
 @param name The configuration parameter name.
 @return ApiDeleteKafkaV3TopicConfigRequest
*/
func (a *ConfigsV3ApiService) DeleteKafkaV3TopicConfig(ctx _context.Context, clusterId string, topicName string, name string) ApiDeleteKafkaV3TopicConfigRequest {
	return ApiDeleteKafkaV3TopicConfigRequest{
		ApiService: a,
		ctx: ctx,
		clusterId: clusterId,
		topicName: topicName,
		name: name,
	}
}

// Execute executes the request
func (a *ConfigsV3ApiService) DeleteKafkaV3TopicConfigExecute(r ApiDeleteKafkaV3TopicConfigRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigsV3ApiService.DeleteKafkaV3TopicConfig")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafka/v3/clusters/{cluster_id}/topics/{topic_name}/configs/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(r.clusterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic_name"+"}", _neturl.PathEscape(parameterToString(r.topicName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetKafkaV3ClusterConfigRequest struct {
	ctx _context.Context
	ApiService ConfigsV3Api
	clusterId string
	name string
}


func (r ApiGetKafkaV3ClusterConfigRequest) Execute() (ClusterConfigData, *_nethttp.Response, error) {
	return r.ApiService.GetKafkaV3ClusterConfigExecute(r)
}

/*
GetKafkaV3ClusterConfig Get Cluster Config

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Returns the configuration parameter specified by ``name``.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId The Kafka cluster ID.
 @param name The configuration parameter name.
 @return ApiGetKafkaV3ClusterConfigRequest
*/
func (a *ConfigsV3ApiService) GetKafkaV3ClusterConfig(ctx _context.Context, clusterId string, name string) ApiGetKafkaV3ClusterConfigRequest {
	return ApiGetKafkaV3ClusterConfigRequest{
		ApiService: a,
		ctx: ctx,
		clusterId: clusterId,
		name: name,
	}
}

// Execute executes the request
//  @return ClusterConfigData
func (a *ConfigsV3ApiService) GetKafkaV3ClusterConfigExecute(r ApiGetKafkaV3ClusterConfigRequest) (ClusterConfigData, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ClusterConfigData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigsV3ApiService.GetKafkaV3ClusterConfig")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafka/v3/clusters/{cluster_id}/broker-configs/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(r.clusterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetKafkaV3TopicConfigRequest struct {
	ctx _context.Context
	ApiService ConfigsV3Api
	clusterId string
	topicName string
	name string
}


func (r ApiGetKafkaV3TopicConfigRequest) Execute() (TopicConfigData, *_nethttp.Response, error) {
	return r.ApiService.GetKafkaV3TopicConfigExecute(r)
}

/*
GetKafkaV3TopicConfig Get Topic Config

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Return the config with the given `name`.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId The Kafka cluster ID.
 @param topicName The topic name.
 @param name The configuration parameter name.
 @return ApiGetKafkaV3TopicConfigRequest
*/
func (a *ConfigsV3ApiService) GetKafkaV3TopicConfig(ctx _context.Context, clusterId string, topicName string, name string) ApiGetKafkaV3TopicConfigRequest {
	return ApiGetKafkaV3TopicConfigRequest{
		ApiService: a,
		ctx: ctx,
		clusterId: clusterId,
		topicName: topicName,
		name: name,
	}
}

// Execute executes the request
//  @return TopicConfigData
func (a *ConfigsV3ApiService) GetKafkaV3TopicConfigExecute(r ApiGetKafkaV3TopicConfigRequest) (TopicConfigData, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TopicConfigData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigsV3ApiService.GetKafkaV3TopicConfig")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafka/v3/clusters/{cluster_id}/topics/{topic_name}/configs/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(r.clusterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic_name"+"}", _neturl.PathEscape(parameterToString(r.topicName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListKafkaV3AllTopicConfigsRequest struct {
	ctx _context.Context
	ApiService ConfigsV3Api
	clusterId string
}


func (r ApiListKafkaV3AllTopicConfigsRequest) Execute() (TopicConfigDataList, *_nethttp.Response, error) {
	return r.ApiService.ListKafkaV3AllTopicConfigsExecute(r)
}

/*
ListKafkaV3AllTopicConfigs Get All Topic Configs

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Returns all topic configurations for topics hosted by the specified
cluster.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId The Kafka cluster ID.
 @return ApiListKafkaV3AllTopicConfigsRequest
*/
func (a *ConfigsV3ApiService) ListKafkaV3AllTopicConfigs(ctx _context.Context, clusterId string) ApiListKafkaV3AllTopicConfigsRequest {
	return ApiListKafkaV3AllTopicConfigsRequest{
		ApiService: a,
		ctx: ctx,
		clusterId: clusterId,
	}
}

// Execute executes the request
//  @return TopicConfigDataList
func (a *ConfigsV3ApiService) ListKafkaV3AllTopicConfigsExecute(r ApiListKafkaV3AllTopicConfigsRequest) (TopicConfigDataList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TopicConfigDataList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigsV3ApiService.ListKafkaV3AllTopicConfigs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafka/v3/clusters/{cluster_id}/topics/-/configs"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(r.clusterId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListKafkaV3ClusterConfigsRequest struct {
	ctx _context.Context
	ApiService ConfigsV3Api
	clusterId string
}


func (r ApiListKafkaV3ClusterConfigsRequest) Execute() (ClusterConfigDataList, *_nethttp.Response, error) {
	return r.ApiService.ListKafkaV3ClusterConfigsExecute(r)
}

/*
ListKafkaV3ClusterConfigs List Cluster Configs

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Returns a list of configuration parameters for the specified Kafka
cluster.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId The Kafka cluster ID.
 @return ApiListKafkaV3ClusterConfigsRequest
*/
func (a *ConfigsV3ApiService) ListKafkaV3ClusterConfigs(ctx _context.Context, clusterId string) ApiListKafkaV3ClusterConfigsRequest {
	return ApiListKafkaV3ClusterConfigsRequest{
		ApiService: a,
		ctx: ctx,
		clusterId: clusterId,
	}
}

// Execute executes the request
//  @return ClusterConfigDataList
func (a *ConfigsV3ApiService) ListKafkaV3ClusterConfigsExecute(r ApiListKafkaV3ClusterConfigsRequest) (ClusterConfigDataList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ClusterConfigDataList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigsV3ApiService.ListKafkaV3ClusterConfigs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafka/v3/clusters/{cluster_id}/broker-configs"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(r.clusterId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListKafkaV3TopicConfigsRequest struct {
	ctx _context.Context
	ApiService ConfigsV3Api
	clusterId string
	topicName string
}


func (r ApiListKafkaV3TopicConfigsRequest) Execute() (TopicConfigDataList, *_nethttp.Response, error) {
	return r.ApiService.ListKafkaV3TopicConfigsExecute(r)
}

/*
ListKafkaV3TopicConfigs List Topic Configs

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Return the list of configs that belong to the specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId The Kafka cluster ID.
 @param topicName The topic name.
 @return ApiListKafkaV3TopicConfigsRequest
*/
func (a *ConfigsV3ApiService) ListKafkaV3TopicConfigs(ctx _context.Context, clusterId string, topicName string) ApiListKafkaV3TopicConfigsRequest {
	return ApiListKafkaV3TopicConfigsRequest{
		ApiService: a,
		ctx: ctx,
		clusterId: clusterId,
		topicName: topicName,
	}
}

// Execute executes the request
//  @return TopicConfigDataList
func (a *ConfigsV3ApiService) ListKafkaV3TopicConfigsExecute(r ApiListKafkaV3TopicConfigsRequest) (TopicConfigDataList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TopicConfigDataList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigsV3ApiService.ListKafkaV3TopicConfigs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafka/v3/clusters/{cluster_id}/topics/{topic_name}/configs"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(r.clusterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic_name"+"}", _neturl.PathEscape(parameterToString(r.topicName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateKafkaV3ClusterConfigRequest struct {
	ctx _context.Context
	ApiService ConfigsV3Api
	clusterId string
	name string
	updateConfigRequestData *UpdateConfigRequestData
}

// The cluster configuration parameter update request.
func (r ApiUpdateKafkaV3ClusterConfigRequest) UpdateConfigRequestData(updateConfigRequestData UpdateConfigRequestData) ApiUpdateKafkaV3ClusterConfigRequest {
	r.updateConfigRequestData = &updateConfigRequestData
	return r
}

func (r ApiUpdateKafkaV3ClusterConfigRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateKafkaV3ClusterConfigExecute(r)
}

/*
UpdateKafkaV3ClusterConfig Update Cluster Config

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Updates the configuration parameter specified by ``name``.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId The Kafka cluster ID.
 @param name The configuration parameter name.
 @return ApiUpdateKafkaV3ClusterConfigRequest
*/
func (a *ConfigsV3ApiService) UpdateKafkaV3ClusterConfig(ctx _context.Context, clusterId string, name string) ApiUpdateKafkaV3ClusterConfigRequest {
	return ApiUpdateKafkaV3ClusterConfigRequest{
		ApiService: a,
		ctx: ctx,
		clusterId: clusterId,
		name: name,
	}
}

// Execute executes the request
func (a *ConfigsV3ApiService) UpdateKafkaV3ClusterConfigExecute(r ApiUpdateKafkaV3ClusterConfigRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigsV3ApiService.UpdateKafkaV3ClusterConfig")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafka/v3/clusters/{cluster_id}/broker-configs/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(r.clusterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateConfigRequestData
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateKafkaV3ClusterConfigsRequest struct {
	ctx _context.Context
	ApiService ConfigsV3Api
	clusterId string
	alterConfigBatchRequestData *AlterConfigBatchRequestData
}

// The alter cluster configuration parameter batch request.
func (r ApiUpdateKafkaV3ClusterConfigsRequest) AlterConfigBatchRequestData(alterConfigBatchRequestData AlterConfigBatchRequestData) ApiUpdateKafkaV3ClusterConfigsRequest {
	r.alterConfigBatchRequestData = &alterConfigBatchRequestData
	return r
}

func (r ApiUpdateKafkaV3ClusterConfigsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateKafkaV3ClusterConfigsExecute(r)
}

/*
UpdateKafkaV3ClusterConfigs Batch Alter Cluster Configs

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Updates or deletes a set of Kafka cluster configuration parameters.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId The Kafka cluster ID.
 @return ApiUpdateKafkaV3ClusterConfigsRequest
*/
func (a *ConfigsV3ApiService) UpdateKafkaV3ClusterConfigs(ctx _context.Context, clusterId string) ApiUpdateKafkaV3ClusterConfigsRequest {
	return ApiUpdateKafkaV3ClusterConfigsRequest{
		ApiService: a,
		ctx: ctx,
		clusterId: clusterId,
	}
}

// Execute executes the request
func (a *ConfigsV3ApiService) UpdateKafkaV3ClusterConfigsExecute(r ApiUpdateKafkaV3ClusterConfigsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigsV3ApiService.UpdateKafkaV3ClusterConfigs")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafka/v3/clusters/{cluster_id}/broker-configs:alter"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(r.clusterId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.alterConfigBatchRequestData
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateKafkaV3TopicConfigRequest struct {
	ctx _context.Context
	ApiService ConfigsV3Api
	clusterId string
	topicName string
	name string
	updateConfigRequestData *UpdateConfigRequestData
}

// The topic configuration parameter update request.
func (r ApiUpdateKafkaV3TopicConfigRequest) UpdateConfigRequestData(updateConfigRequestData UpdateConfigRequestData) ApiUpdateKafkaV3TopicConfigRequest {
	r.updateConfigRequestData = &updateConfigRequestData
	return r
}

func (r ApiUpdateKafkaV3TopicConfigRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateKafkaV3TopicConfigExecute(r)
}

/*
UpdateKafkaV3TopicConfig Update Topic Config

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Updates the config with given `name`.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId The Kafka cluster ID.
 @param topicName The topic name.
 @param name The configuration parameter name.
 @return ApiUpdateKafkaV3TopicConfigRequest
*/
func (a *ConfigsV3ApiService) UpdateKafkaV3TopicConfig(ctx _context.Context, clusterId string, topicName string, name string) ApiUpdateKafkaV3TopicConfigRequest {
	return ApiUpdateKafkaV3TopicConfigRequest{
		ApiService: a,
		ctx: ctx,
		clusterId: clusterId,
		topicName: topicName,
		name: name,
	}
}

// Execute executes the request
func (a *ConfigsV3ApiService) UpdateKafkaV3TopicConfigExecute(r ApiUpdateKafkaV3TopicConfigRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigsV3ApiService.UpdateKafkaV3TopicConfig")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafka/v3/clusters/{cluster_id}/topics/{topic_name}/configs/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(r.clusterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic_name"+"}", _neturl.PathEscape(parameterToString(r.topicName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateConfigRequestData
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateKafkaV3TopicConfigBatchRequest struct {
	ctx _context.Context
	ApiService ConfigsV3Api
	clusterId string
	topicName string
	alterConfigBatchRequestData *AlterConfigBatchRequestData
}

// The alter topic configuration parameter batch request.
func (r ApiUpdateKafkaV3TopicConfigBatchRequest) AlterConfigBatchRequestData(alterConfigBatchRequestData AlterConfigBatchRequestData) ApiUpdateKafkaV3TopicConfigBatchRequest {
	r.alterConfigBatchRequestData = &alterConfigBatchRequestData
	return r
}

func (r ApiUpdateKafkaV3TopicConfigBatchRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateKafkaV3TopicConfigBatchExecute(r)
}

/*
UpdateKafkaV3TopicConfigBatch Batch Alter Topic Configs

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Updates or deletes a set of topic configs.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId The Kafka cluster ID.
 @param topicName The topic name.
 @return ApiUpdateKafkaV3TopicConfigBatchRequest
*/
func (a *ConfigsV3ApiService) UpdateKafkaV3TopicConfigBatch(ctx _context.Context, clusterId string, topicName string) ApiUpdateKafkaV3TopicConfigBatchRequest {
	return ApiUpdateKafkaV3TopicConfigBatchRequest{
		ApiService: a,
		ctx: ctx,
		clusterId: clusterId,
		topicName: topicName,
	}
}

// Execute executes the request
func (a *ConfigsV3ApiService) UpdateKafkaV3TopicConfigBatchExecute(r ApiUpdateKafkaV3TopicConfigBatchRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigsV3ApiService.UpdateKafkaV3TopicConfigBatch")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafka/v3/clusters/{cluster_id}/topics/{topic_name}/configs:alter"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(r.clusterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic_name"+"}", _neturl.PathEscape(parameterToString(r.topicName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.alterConfigBatchRequestData
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
