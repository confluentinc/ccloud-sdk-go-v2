// Copyright 2021 Confluent Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*
REST Admin API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 3.0.0
Contact: kafka-clients-proxy-team@confluent.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v3

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

type ClusterLinkingV3Api interface {

	/*
	CreateKafkaV3Link Create a cluster link

	[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param clusterId The Kafka cluster ID.
	 @return ApiCreateKafkaV3LinkRequest
	*/
	CreateKafkaV3Link(ctx _context.Context, clusterId string) ApiCreateKafkaV3LinkRequest

	// CreateKafkaV3LinkExecute executes the request
	CreateKafkaV3LinkExecute(r ApiCreateKafkaV3LinkRequest) (*_nethttp.Response, error)

	/*
	CreateKafkaV3MirrorTopic Create a mirror topic

	[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Create a topic in the destination cluster mirroring a topic in
the source cluster

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param clusterId The Kafka cluster ID.
	 @param linkName The link name
	 @return ApiCreateKafkaV3MirrorTopicRequest
	*/
	CreateKafkaV3MirrorTopic(ctx _context.Context, clusterId string, linkName string) ApiCreateKafkaV3MirrorTopicRequest

	// CreateKafkaV3MirrorTopicExecute executes the request
	CreateKafkaV3MirrorTopicExecute(r ApiCreateKafkaV3MirrorTopicRequest) (*_nethttp.Response, error)

	/*
	DeleteKafkaV3Link Delete the cluster link

	[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param clusterId The Kafka cluster ID.
	 @param linkName The link name
	 @return ApiDeleteKafkaV3LinkRequest
	*/
	DeleteKafkaV3Link(ctx _context.Context, clusterId string, linkName string) ApiDeleteKafkaV3LinkRequest

	// DeleteKafkaV3LinkExecute executes the request
	DeleteKafkaV3LinkExecute(r ApiDeleteKafkaV3LinkRequest) (*_nethttp.Response, error)

	/*
	DeleteKafkaV3LinkConfig Reset the given config to default value

	[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param clusterId The Kafka cluster ID.
	 @param linkName The link name
	 @param configName The link config name
	 @return ApiDeleteKafkaV3LinkConfigRequest
	*/
	DeleteKafkaV3LinkConfig(ctx _context.Context, clusterId string, linkName string, configName string) ApiDeleteKafkaV3LinkConfigRequest

	// DeleteKafkaV3LinkConfigExecute executes the request
	DeleteKafkaV3LinkConfigExecute(r ApiDeleteKafkaV3LinkConfigRequest) (*_nethttp.Response, error)

	/*
	GetKafkaV3Link Describe the cluster link

	[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param clusterId The Kafka cluster ID.
	 @param linkName The link name
	 @return ApiGetKafkaV3LinkRequest
	*/
	GetKafkaV3Link(ctx _context.Context, clusterId string, linkName string) ApiGetKafkaV3LinkRequest

	// GetKafkaV3LinkExecute executes the request
	//  @return ListLinksResponseData
	GetKafkaV3LinkExecute(r ApiGetKafkaV3LinkRequest) (ListLinksResponseData, *_nethttp.Response, error)

	/*
	GetKafkaV3LinkConfigs Describe the config under the cluster link

	[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param clusterId The Kafka cluster ID.
	 @param linkName The link name
	 @param configName The link config name
	 @return ApiGetKafkaV3LinkConfigsRequest
	*/
	GetKafkaV3LinkConfigs(ctx _context.Context, clusterId string, linkName string, configName string) ApiGetKafkaV3LinkConfigsRequest

	// GetKafkaV3LinkConfigsExecute executes the request
	//  @return ListLinkConfigsResponseData
	GetKafkaV3LinkConfigsExecute(r ApiGetKafkaV3LinkConfigsRequest) (ListLinkConfigsResponseData, *_nethttp.Response, error)

	/*
	ListKafkaV3LinkConfigs List all configs of the cluster link

	[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param clusterId The Kafka cluster ID.
	 @param linkName The link name
	 @return ApiListKafkaV3LinkConfigsRequest
	*/
	ListKafkaV3LinkConfigs(ctx _context.Context, clusterId string, linkName string) ApiListKafkaV3LinkConfigsRequest

	// ListKafkaV3LinkConfigsExecute executes the request
	//  @return ListLinkConfigsResponseDataList
	ListKafkaV3LinkConfigsExecute(r ApiListKafkaV3LinkConfigsRequest) (ListLinkConfigsResponseDataList, *_nethttp.Response, error)

	/*
	ListKafkaV3Links List all cluster links in the dest cluster

	[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param clusterId The Kafka cluster ID.
	 @return ApiListKafkaV3LinksRequest
	*/
	ListKafkaV3Links(ctx _context.Context, clusterId string) ApiListKafkaV3LinksRequest

	// ListKafkaV3LinksExecute executes the request
	//  @return ListLinksResponseDataList
	ListKafkaV3LinksExecute(r ApiListKafkaV3LinksRequest) (ListLinksResponseDataList, *_nethttp.Response, error)

	/*
	ListKafkaV3MirrorTopics List mirror topics

	[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

List all mirror topics in the cluster

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param clusterId The Kafka cluster ID.
	 @return ApiListKafkaV3MirrorTopicsRequest
	*/
	ListKafkaV3MirrorTopics(ctx _context.Context, clusterId string) ApiListKafkaV3MirrorTopicsRequest

	// ListKafkaV3MirrorTopicsExecute executes the request
	//  @return ListMirrorTopicsResponseDataList
	ListKafkaV3MirrorTopicsExecute(r ApiListKafkaV3MirrorTopicsRequest) (ListMirrorTopicsResponseDataList, *_nethttp.Response, error)

	/*
	ListKafkaV3MirrorTopicsUnderLink List mirror topics

	[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

List all mirror topics under the link

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param clusterId The Kafka cluster ID.
	 @param linkName The link name
	 @return ApiListKafkaV3MirrorTopicsUnderLinkRequest
	*/
	ListKafkaV3MirrorTopicsUnderLink(ctx _context.Context, clusterId string, linkName string) ApiListKafkaV3MirrorTopicsUnderLinkRequest

	// ListKafkaV3MirrorTopicsUnderLinkExecute executes the request
	//  @return ListMirrorTopicsResponseDataList
	ListKafkaV3MirrorTopicsUnderLinkExecute(r ApiListKafkaV3MirrorTopicsUnderLinkRequest) (ListMirrorTopicsResponseDataList, *_nethttp.Response, error)

	/*
	ReadKafkaV3MirrorTopic Describe the mirror topic

	[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param clusterId The Kafka cluster ID.
	 @param linkName The link name
	 @param mirrorTopicName Cluster Linking mirror topic name
	 @return ApiReadKafkaV3MirrorTopicRequest
	*/
	ReadKafkaV3MirrorTopic(ctx _context.Context, clusterId string, linkName string, mirrorTopicName string) ApiReadKafkaV3MirrorTopicRequest

	// ReadKafkaV3MirrorTopicExecute executes the request
	//  @return ListMirrorTopicsResponseData
	ReadKafkaV3MirrorTopicExecute(r ApiReadKafkaV3MirrorTopicRequest) (ListMirrorTopicsResponseData, *_nethttp.Response, error)

	/*
	UpdateKafkaV3LinkConfig Alter the config under the cluster link

	[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param clusterId The Kafka cluster ID.
	 @param linkName The link name
	 @param configName The link config name
	 @return ApiUpdateKafkaV3LinkConfigRequest
	*/
	UpdateKafkaV3LinkConfig(ctx _context.Context, clusterId string, linkName string, configName string) ApiUpdateKafkaV3LinkConfigRequest

	// UpdateKafkaV3LinkConfigExecute executes the request
	UpdateKafkaV3LinkConfigExecute(r ApiUpdateKafkaV3LinkConfigRequest) (*_nethttp.Response, error)

	/*
	UpdateKafkaV3LinkConfigBatch Batch Alter Topic Configs

	[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Batch Alter Link Configs

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param clusterId The Kafka cluster ID.
	 @param linkName The link name
	 @return ApiUpdateKafkaV3LinkConfigBatchRequest
	*/
	UpdateKafkaV3LinkConfigBatch(ctx _context.Context, clusterId string, linkName string) ApiUpdateKafkaV3LinkConfigBatchRequest

	// UpdateKafkaV3LinkConfigBatchExecute executes the request
	UpdateKafkaV3LinkConfigBatchExecute(r ApiUpdateKafkaV3LinkConfigBatchRequest) (*_nethttp.Response, error)

	/*
	UpdateKafkaV3MirrorTopicsFailover Failover the mirror topics

	[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param clusterId The Kafka cluster ID.
	 @param linkName The link name
	 @return ApiUpdateKafkaV3MirrorTopicsFailoverRequest
	*/
	UpdateKafkaV3MirrorTopicsFailover(ctx _context.Context, clusterId string, linkName string) ApiUpdateKafkaV3MirrorTopicsFailoverRequest

	// UpdateKafkaV3MirrorTopicsFailoverExecute executes the request
	//  @return AlterMirrorStatusResponseDataList
	UpdateKafkaV3MirrorTopicsFailoverExecute(r ApiUpdateKafkaV3MirrorTopicsFailoverRequest) (AlterMirrorStatusResponseDataList, *_nethttp.Response, error)

	/*
	UpdateKafkaV3MirrorTopicsPause Pause the mirror topics

	[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param clusterId The Kafka cluster ID.
	 @param linkName The link name
	 @return ApiUpdateKafkaV3MirrorTopicsPauseRequest
	*/
	UpdateKafkaV3MirrorTopicsPause(ctx _context.Context, clusterId string, linkName string) ApiUpdateKafkaV3MirrorTopicsPauseRequest

	// UpdateKafkaV3MirrorTopicsPauseExecute executes the request
	//  @return AlterMirrorStatusResponseDataList
	UpdateKafkaV3MirrorTopicsPauseExecute(r ApiUpdateKafkaV3MirrorTopicsPauseRequest) (AlterMirrorStatusResponseDataList, *_nethttp.Response, error)

	/*
	UpdateKafkaV3MirrorTopicsPromote Promote the mirror topics

	[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param clusterId The Kafka cluster ID.
	 @param linkName The link name
	 @return ApiUpdateKafkaV3MirrorTopicsPromoteRequest
	*/
	UpdateKafkaV3MirrorTopicsPromote(ctx _context.Context, clusterId string, linkName string) ApiUpdateKafkaV3MirrorTopicsPromoteRequest

	// UpdateKafkaV3MirrorTopicsPromoteExecute executes the request
	//  @return AlterMirrorStatusResponseDataList
	UpdateKafkaV3MirrorTopicsPromoteExecute(r ApiUpdateKafkaV3MirrorTopicsPromoteRequest) (AlterMirrorStatusResponseDataList, *_nethttp.Response, error)

	/*
	UpdateKafkaV3MirrorTopicsResume Resume the mirror topics

	[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param clusterId The Kafka cluster ID.
	 @param linkName The link name
	 @return ApiUpdateKafkaV3MirrorTopicsResumeRequest
	*/
	UpdateKafkaV3MirrorTopicsResume(ctx _context.Context, clusterId string, linkName string) ApiUpdateKafkaV3MirrorTopicsResumeRequest

	// UpdateKafkaV3MirrorTopicsResumeExecute executes the request
	//  @return AlterMirrorStatusResponseDataList
	UpdateKafkaV3MirrorTopicsResumeExecute(r ApiUpdateKafkaV3MirrorTopicsResumeRequest) (AlterMirrorStatusResponseDataList, *_nethttp.Response, error)
}

// ClusterLinkingV3ApiService ClusterLinkingV3Api service
type ClusterLinkingV3ApiService service

type ApiCreateKafkaV3LinkRequest struct {
	ctx _context.Context
	ApiService ClusterLinkingV3Api
	clusterId string
	createLinkRequestData *CreateLinkRequestData
}

// Create a cluster link
func (r ApiCreateKafkaV3LinkRequest) CreateLinkRequestData(createLinkRequestData CreateLinkRequestData) ApiCreateKafkaV3LinkRequest {
	r.createLinkRequestData = &createLinkRequestData
	return r
}

func (r ApiCreateKafkaV3LinkRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CreateKafkaV3LinkExecute(r)
}

/*
CreateKafkaV3Link Create a cluster link

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId The Kafka cluster ID.
 @return ApiCreateKafkaV3LinkRequest
*/
func (a *ClusterLinkingV3ApiService) CreateKafkaV3Link(ctx _context.Context, clusterId string) ApiCreateKafkaV3LinkRequest {
	return ApiCreateKafkaV3LinkRequest{
		ApiService: a,
		ctx: ctx,
		clusterId: clusterId,
	}
}

// Execute executes the request
func (a *ClusterLinkingV3ApiService) CreateKafkaV3LinkExecute(r ApiCreateKafkaV3LinkRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterLinkingV3ApiService.CreateKafkaV3Link")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafka/v3/clusters/{cluster_id}/links"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(r.clusterId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createLinkRequestData
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateKafkaV3MirrorTopicRequest struct {
	ctx _context.Context
	ApiService ClusterLinkingV3Api
	clusterId string
	linkName string
	createMirrorTopicRequestData *CreateMirrorTopicRequestData
}

// Name and configs of the topics mirroring from and mirroring to
func (r ApiCreateKafkaV3MirrorTopicRequest) CreateMirrorTopicRequestData(createMirrorTopicRequestData CreateMirrorTopicRequestData) ApiCreateKafkaV3MirrorTopicRequest {
	r.createMirrorTopicRequestData = &createMirrorTopicRequestData
	return r
}

func (r ApiCreateKafkaV3MirrorTopicRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CreateKafkaV3MirrorTopicExecute(r)
}

/*
CreateKafkaV3MirrorTopic Create a mirror topic

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Create a topic in the destination cluster mirroring a topic in
the source cluster

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId The Kafka cluster ID.
 @param linkName The link name
 @return ApiCreateKafkaV3MirrorTopicRequest
*/
func (a *ClusterLinkingV3ApiService) CreateKafkaV3MirrorTopic(ctx _context.Context, clusterId string, linkName string) ApiCreateKafkaV3MirrorTopicRequest {
	return ApiCreateKafkaV3MirrorTopicRequest{
		ApiService: a,
		ctx: ctx,
		clusterId: clusterId,
		linkName: linkName,
	}
}

// Execute executes the request
func (a *ClusterLinkingV3ApiService) CreateKafkaV3MirrorTopicExecute(r ApiCreateKafkaV3MirrorTopicRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterLinkingV3ApiService.CreateKafkaV3MirrorTopic")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafka/v3/clusters/{cluster_id}/links/{link_name}/mirrors"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(r.clusterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"link_name"+"}", _neturl.PathEscape(parameterToString(r.linkName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createMirrorTopicRequestData
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteKafkaV3LinkRequest struct {
	ctx _context.Context
	ApiService ClusterLinkingV3Api
	clusterId string
	linkName string
}


func (r ApiDeleteKafkaV3LinkRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKafkaV3LinkExecute(r)
}

/*
DeleteKafkaV3Link Delete the cluster link

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId The Kafka cluster ID.
 @param linkName The link name
 @return ApiDeleteKafkaV3LinkRequest
*/
func (a *ClusterLinkingV3ApiService) DeleteKafkaV3Link(ctx _context.Context, clusterId string, linkName string) ApiDeleteKafkaV3LinkRequest {
	return ApiDeleteKafkaV3LinkRequest{
		ApiService: a,
		ctx: ctx,
		clusterId: clusterId,
		linkName: linkName,
	}
}

// Execute executes the request
func (a *ClusterLinkingV3ApiService) DeleteKafkaV3LinkExecute(r ApiDeleteKafkaV3LinkRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterLinkingV3ApiService.DeleteKafkaV3Link")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafka/v3/clusters/{cluster_id}/links/{link_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(r.clusterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"link_name"+"}", _neturl.PathEscape(parameterToString(r.linkName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteKafkaV3LinkConfigRequest struct {
	ctx _context.Context
	ApiService ClusterLinkingV3Api
	clusterId string
	linkName string
	configName string
}


func (r ApiDeleteKafkaV3LinkConfigRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKafkaV3LinkConfigExecute(r)
}

/*
DeleteKafkaV3LinkConfig Reset the given config to default value

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId The Kafka cluster ID.
 @param linkName The link name
 @param configName The link config name
 @return ApiDeleteKafkaV3LinkConfigRequest
*/
func (a *ClusterLinkingV3ApiService) DeleteKafkaV3LinkConfig(ctx _context.Context, clusterId string, linkName string, configName string) ApiDeleteKafkaV3LinkConfigRequest {
	return ApiDeleteKafkaV3LinkConfigRequest{
		ApiService: a,
		ctx: ctx,
		clusterId: clusterId,
		linkName: linkName,
		configName: configName,
	}
}

// Execute executes the request
func (a *ClusterLinkingV3ApiService) DeleteKafkaV3LinkConfigExecute(r ApiDeleteKafkaV3LinkConfigRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterLinkingV3ApiService.DeleteKafkaV3LinkConfig")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafka/v3/clusters/{cluster_id}/links/{link_name}/configs/{config_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(r.clusterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"link_name"+"}", _neturl.PathEscape(parameterToString(r.linkName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"config_name"+"}", _neturl.PathEscape(parameterToString(r.configName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetKafkaV3LinkRequest struct {
	ctx _context.Context
	ApiService ClusterLinkingV3Api
	clusterId string
	linkName string
}


func (r ApiGetKafkaV3LinkRequest) Execute() (ListLinksResponseData, *_nethttp.Response, error) {
	return r.ApiService.GetKafkaV3LinkExecute(r)
}

/*
GetKafkaV3Link Describe the cluster link

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId The Kafka cluster ID.
 @param linkName The link name
 @return ApiGetKafkaV3LinkRequest
*/
func (a *ClusterLinkingV3ApiService) GetKafkaV3Link(ctx _context.Context, clusterId string, linkName string) ApiGetKafkaV3LinkRequest {
	return ApiGetKafkaV3LinkRequest{
		ApiService: a,
		ctx: ctx,
		clusterId: clusterId,
		linkName: linkName,
	}
}

// Execute executes the request
//  @return ListLinksResponseData
func (a *ClusterLinkingV3ApiService) GetKafkaV3LinkExecute(r ApiGetKafkaV3LinkRequest) (ListLinksResponseData, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ListLinksResponseData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterLinkingV3ApiService.GetKafkaV3Link")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafka/v3/clusters/{cluster_id}/links/{link_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(r.clusterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"link_name"+"}", _neturl.PathEscape(parameterToString(r.linkName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetKafkaV3LinkConfigsRequest struct {
	ctx _context.Context
	ApiService ClusterLinkingV3Api
	clusterId string
	linkName string
	configName string
}


func (r ApiGetKafkaV3LinkConfigsRequest) Execute() (ListLinkConfigsResponseData, *_nethttp.Response, error) {
	return r.ApiService.GetKafkaV3LinkConfigsExecute(r)
}

/*
GetKafkaV3LinkConfigs Describe the config under the cluster link

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId The Kafka cluster ID.
 @param linkName The link name
 @param configName The link config name
 @return ApiGetKafkaV3LinkConfigsRequest
*/
func (a *ClusterLinkingV3ApiService) GetKafkaV3LinkConfigs(ctx _context.Context, clusterId string, linkName string, configName string) ApiGetKafkaV3LinkConfigsRequest {
	return ApiGetKafkaV3LinkConfigsRequest{
		ApiService: a,
		ctx: ctx,
		clusterId: clusterId,
		linkName: linkName,
		configName: configName,
	}
}

// Execute executes the request
//  @return ListLinkConfigsResponseData
func (a *ClusterLinkingV3ApiService) GetKafkaV3LinkConfigsExecute(r ApiGetKafkaV3LinkConfigsRequest) (ListLinkConfigsResponseData, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ListLinkConfigsResponseData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterLinkingV3ApiService.GetKafkaV3LinkConfigs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafka/v3/clusters/{cluster_id}/links/{link_name}/configs/{config_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(r.clusterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"link_name"+"}", _neturl.PathEscape(parameterToString(r.linkName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"config_name"+"}", _neturl.PathEscape(parameterToString(r.configName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListKafkaV3LinkConfigsRequest struct {
	ctx _context.Context
	ApiService ClusterLinkingV3Api
	clusterId string
	linkName string
}


func (r ApiListKafkaV3LinkConfigsRequest) Execute() (ListLinkConfigsResponseDataList, *_nethttp.Response, error) {
	return r.ApiService.ListKafkaV3LinkConfigsExecute(r)
}

/*
ListKafkaV3LinkConfigs List all configs of the cluster link

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId The Kafka cluster ID.
 @param linkName The link name
 @return ApiListKafkaV3LinkConfigsRequest
*/
func (a *ClusterLinkingV3ApiService) ListKafkaV3LinkConfigs(ctx _context.Context, clusterId string, linkName string) ApiListKafkaV3LinkConfigsRequest {
	return ApiListKafkaV3LinkConfigsRequest{
		ApiService: a,
		ctx: ctx,
		clusterId: clusterId,
		linkName: linkName,
	}
}

// Execute executes the request
//  @return ListLinkConfigsResponseDataList
func (a *ClusterLinkingV3ApiService) ListKafkaV3LinkConfigsExecute(r ApiListKafkaV3LinkConfigsRequest) (ListLinkConfigsResponseDataList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ListLinkConfigsResponseDataList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterLinkingV3ApiService.ListKafkaV3LinkConfigs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafka/v3/clusters/{cluster_id}/links/{link_name}/configs"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(r.clusterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"link_name"+"}", _neturl.PathEscape(parameterToString(r.linkName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListKafkaV3LinksRequest struct {
	ctx _context.Context
	ApiService ClusterLinkingV3Api
	clusterId string
}


func (r ApiListKafkaV3LinksRequest) Execute() (ListLinksResponseDataList, *_nethttp.Response, error) {
	return r.ApiService.ListKafkaV3LinksExecute(r)
}

/*
ListKafkaV3Links List all cluster links in the dest cluster

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId The Kafka cluster ID.
 @return ApiListKafkaV3LinksRequest
*/
func (a *ClusterLinkingV3ApiService) ListKafkaV3Links(ctx _context.Context, clusterId string) ApiListKafkaV3LinksRequest {
	return ApiListKafkaV3LinksRequest{
		ApiService: a,
		ctx: ctx,
		clusterId: clusterId,
	}
}

// Execute executes the request
//  @return ListLinksResponseDataList
func (a *ClusterLinkingV3ApiService) ListKafkaV3LinksExecute(r ApiListKafkaV3LinksRequest) (ListLinksResponseDataList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ListLinksResponseDataList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterLinkingV3ApiService.ListKafkaV3Links")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafka/v3/clusters/{cluster_id}/links"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(r.clusterId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListKafkaV3MirrorTopicsRequest struct {
	ctx _context.Context
	ApiService ClusterLinkingV3Api
	clusterId string
	mirrorStatus *MirrorTopicStatus
}

// The status of the mirror topic. If not specified, all mirror topics will be returned.
func (r ApiListKafkaV3MirrorTopicsRequest) MirrorStatus(mirrorStatus MirrorTopicStatus) ApiListKafkaV3MirrorTopicsRequest {
	r.mirrorStatus = &mirrorStatus
	return r
}

func (r ApiListKafkaV3MirrorTopicsRequest) Execute() (ListMirrorTopicsResponseDataList, *_nethttp.Response, error) {
	return r.ApiService.ListKafkaV3MirrorTopicsExecute(r)
}

/*
ListKafkaV3MirrorTopics List mirror topics

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

List all mirror topics in the cluster

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId The Kafka cluster ID.
 @return ApiListKafkaV3MirrorTopicsRequest
*/
func (a *ClusterLinkingV3ApiService) ListKafkaV3MirrorTopics(ctx _context.Context, clusterId string) ApiListKafkaV3MirrorTopicsRequest {
	return ApiListKafkaV3MirrorTopicsRequest{
		ApiService: a,
		ctx: ctx,
		clusterId: clusterId,
	}
}

// Execute executes the request
//  @return ListMirrorTopicsResponseDataList
func (a *ClusterLinkingV3ApiService) ListKafkaV3MirrorTopicsExecute(r ApiListKafkaV3MirrorTopicsRequest) (ListMirrorTopicsResponseDataList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ListMirrorTopicsResponseDataList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterLinkingV3ApiService.ListKafkaV3MirrorTopics")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafka/v3/clusters/{cluster_id}/links/-/mirrors"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(r.clusterId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.mirrorStatus != nil {
		localVarQueryParams.Add("mirror_status", parameterToString(*r.mirrorStatus, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListKafkaV3MirrorTopicsUnderLinkRequest struct {
	ctx _context.Context
	ApiService ClusterLinkingV3Api
	clusterId string
	linkName string
	mirrorStatus *MirrorTopicStatus
}

// The status of the mirror topic. If not specified, all mirror topics will be returned.
func (r ApiListKafkaV3MirrorTopicsUnderLinkRequest) MirrorStatus(mirrorStatus MirrorTopicStatus) ApiListKafkaV3MirrorTopicsUnderLinkRequest {
	r.mirrorStatus = &mirrorStatus
	return r
}

func (r ApiListKafkaV3MirrorTopicsUnderLinkRequest) Execute() (ListMirrorTopicsResponseDataList, *_nethttp.Response, error) {
	return r.ApiService.ListKafkaV3MirrorTopicsUnderLinkExecute(r)
}

/*
ListKafkaV3MirrorTopicsUnderLink List mirror topics

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

List all mirror topics under the link

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId The Kafka cluster ID.
 @param linkName The link name
 @return ApiListKafkaV3MirrorTopicsUnderLinkRequest
*/
func (a *ClusterLinkingV3ApiService) ListKafkaV3MirrorTopicsUnderLink(ctx _context.Context, clusterId string, linkName string) ApiListKafkaV3MirrorTopicsUnderLinkRequest {
	return ApiListKafkaV3MirrorTopicsUnderLinkRequest{
		ApiService: a,
		ctx: ctx,
		clusterId: clusterId,
		linkName: linkName,
	}
}

// Execute executes the request
//  @return ListMirrorTopicsResponseDataList
func (a *ClusterLinkingV3ApiService) ListKafkaV3MirrorTopicsUnderLinkExecute(r ApiListKafkaV3MirrorTopicsUnderLinkRequest) (ListMirrorTopicsResponseDataList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ListMirrorTopicsResponseDataList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterLinkingV3ApiService.ListKafkaV3MirrorTopicsUnderLink")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafka/v3/clusters/{cluster_id}/links/{link_name}/mirrors"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(r.clusterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"link_name"+"}", _neturl.PathEscape(parameterToString(r.linkName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.mirrorStatus != nil {
		localVarQueryParams.Add("mirror_status", parameterToString(*r.mirrorStatus, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadKafkaV3MirrorTopicRequest struct {
	ctx _context.Context
	ApiService ClusterLinkingV3Api
	clusterId string
	linkName string
	mirrorTopicName string
}


func (r ApiReadKafkaV3MirrorTopicRequest) Execute() (ListMirrorTopicsResponseData, *_nethttp.Response, error) {
	return r.ApiService.ReadKafkaV3MirrorTopicExecute(r)
}

/*
ReadKafkaV3MirrorTopic Describe the mirror topic

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId The Kafka cluster ID.
 @param linkName The link name
 @param mirrorTopicName Cluster Linking mirror topic name
 @return ApiReadKafkaV3MirrorTopicRequest
*/
func (a *ClusterLinkingV3ApiService) ReadKafkaV3MirrorTopic(ctx _context.Context, clusterId string, linkName string, mirrorTopicName string) ApiReadKafkaV3MirrorTopicRequest {
	return ApiReadKafkaV3MirrorTopicRequest{
		ApiService: a,
		ctx: ctx,
		clusterId: clusterId,
		linkName: linkName,
		mirrorTopicName: mirrorTopicName,
	}
}

// Execute executes the request
//  @return ListMirrorTopicsResponseData
func (a *ClusterLinkingV3ApiService) ReadKafkaV3MirrorTopicExecute(r ApiReadKafkaV3MirrorTopicRequest) (ListMirrorTopicsResponseData, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ListMirrorTopicsResponseData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterLinkingV3ApiService.ReadKafkaV3MirrorTopic")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafka/v3/clusters/{cluster_id}/links/{link_name}/mirrors/{mirror_topic_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(r.clusterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"link_name"+"}", _neturl.PathEscape(parameterToString(r.linkName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mirror_topic_name"+"}", _neturl.PathEscape(parameterToString(r.mirrorTopicName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateKafkaV3LinkConfigRequest struct {
	ctx _context.Context
	ApiService ClusterLinkingV3Api
	clusterId string
	linkName string
	configName string
	updateLinkConfigRequestData *UpdateLinkConfigRequestData
}

// Link config value to update
func (r ApiUpdateKafkaV3LinkConfigRequest) UpdateLinkConfigRequestData(updateLinkConfigRequestData UpdateLinkConfigRequestData) ApiUpdateKafkaV3LinkConfigRequest {
	r.updateLinkConfigRequestData = &updateLinkConfigRequestData
	return r
}

func (r ApiUpdateKafkaV3LinkConfigRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateKafkaV3LinkConfigExecute(r)
}

/*
UpdateKafkaV3LinkConfig Alter the config under the cluster link

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId The Kafka cluster ID.
 @param linkName The link name
 @param configName The link config name
 @return ApiUpdateKafkaV3LinkConfigRequest
*/
func (a *ClusterLinkingV3ApiService) UpdateKafkaV3LinkConfig(ctx _context.Context, clusterId string, linkName string, configName string) ApiUpdateKafkaV3LinkConfigRequest {
	return ApiUpdateKafkaV3LinkConfigRequest{
		ApiService: a,
		ctx: ctx,
		clusterId: clusterId,
		linkName: linkName,
		configName: configName,
	}
}

// Execute executes the request
func (a *ClusterLinkingV3ApiService) UpdateKafkaV3LinkConfigExecute(r ApiUpdateKafkaV3LinkConfigRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterLinkingV3ApiService.UpdateKafkaV3LinkConfig")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafka/v3/clusters/{cluster_id}/links/{link_name}/configs/{config_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(r.clusterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"link_name"+"}", _neturl.PathEscape(parameterToString(r.linkName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"config_name"+"}", _neturl.PathEscape(parameterToString(r.configName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateLinkConfigRequestData
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateKafkaV3LinkConfigBatchRequest struct {
	ctx _context.Context
	ApiService ClusterLinkingV3Api
	clusterId string
	linkName string
	alterConfigBatchRequestData *AlterConfigBatchRequestData
}

func (r ApiUpdateKafkaV3LinkConfigBatchRequest) AlterConfigBatchRequestData(alterConfigBatchRequestData AlterConfigBatchRequestData) ApiUpdateKafkaV3LinkConfigBatchRequest {
	r.alterConfigBatchRequestData = &alterConfigBatchRequestData
	return r
}

func (r ApiUpdateKafkaV3LinkConfigBatchRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateKafkaV3LinkConfigBatchExecute(r)
}

/*
UpdateKafkaV3LinkConfigBatch Batch Alter Topic Configs

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Batch Alter Link Configs

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId The Kafka cluster ID.
 @param linkName The link name
 @return ApiUpdateKafkaV3LinkConfigBatchRequest
*/
func (a *ClusterLinkingV3ApiService) UpdateKafkaV3LinkConfigBatch(ctx _context.Context, clusterId string, linkName string) ApiUpdateKafkaV3LinkConfigBatchRequest {
	return ApiUpdateKafkaV3LinkConfigBatchRequest{
		ApiService: a,
		ctx: ctx,
		clusterId: clusterId,
		linkName: linkName,
	}
}

// Execute executes the request
func (a *ClusterLinkingV3ApiService) UpdateKafkaV3LinkConfigBatchExecute(r ApiUpdateKafkaV3LinkConfigBatchRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterLinkingV3ApiService.UpdateKafkaV3LinkConfigBatch")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafka/v3/clusters/{cluster_id}/links/{link_name}/configs:alter"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(r.clusterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"link_name"+"}", _neturl.PathEscape(parameterToString(r.linkName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.alterConfigBatchRequestData
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateKafkaV3MirrorTopicsFailoverRequest struct {
	ctx _context.Context
	ApiService ClusterLinkingV3Api
	clusterId string
	linkName string
	validateOnly *bool
	alterMirrorsRequestData *AlterMirrorsRequestData
}

// To validate if the link can be created or not, but not to create it. Default: false
func (r ApiUpdateKafkaV3MirrorTopicsFailoverRequest) ValidateOnly(validateOnly bool) ApiUpdateKafkaV3MirrorTopicsFailoverRequest {
	r.validateOnly = &validateOnly
	return r
}
// Name of the topics to apply the changes
func (r ApiUpdateKafkaV3MirrorTopicsFailoverRequest) AlterMirrorsRequestData(alterMirrorsRequestData AlterMirrorsRequestData) ApiUpdateKafkaV3MirrorTopicsFailoverRequest {
	r.alterMirrorsRequestData = &alterMirrorsRequestData
	return r
}

func (r ApiUpdateKafkaV3MirrorTopicsFailoverRequest) Execute() (AlterMirrorStatusResponseDataList, *_nethttp.Response, error) {
	return r.ApiService.UpdateKafkaV3MirrorTopicsFailoverExecute(r)
}

/*
UpdateKafkaV3MirrorTopicsFailover Failover the mirror topics

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId The Kafka cluster ID.
 @param linkName The link name
 @return ApiUpdateKafkaV3MirrorTopicsFailoverRequest
*/
func (a *ClusterLinkingV3ApiService) UpdateKafkaV3MirrorTopicsFailover(ctx _context.Context, clusterId string, linkName string) ApiUpdateKafkaV3MirrorTopicsFailoverRequest {
	return ApiUpdateKafkaV3MirrorTopicsFailoverRequest{
		ApiService: a,
		ctx: ctx,
		clusterId: clusterId,
		linkName: linkName,
	}
}

// Execute executes the request
//  @return AlterMirrorStatusResponseDataList
func (a *ClusterLinkingV3ApiService) UpdateKafkaV3MirrorTopicsFailoverExecute(r ApiUpdateKafkaV3MirrorTopicsFailoverRequest) (AlterMirrorStatusResponseDataList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AlterMirrorStatusResponseDataList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterLinkingV3ApiService.UpdateKafkaV3MirrorTopicsFailover")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafka/v3/clusters/{cluster_id}/links/{link_name}/mirrors:failover"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(r.clusterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"link_name"+"}", _neturl.PathEscape(parameterToString(r.linkName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.validateOnly != nil {
		localVarQueryParams.Add("validate_only", parameterToString(*r.validateOnly, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.alterMirrorsRequestData
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateKafkaV3MirrorTopicsPauseRequest struct {
	ctx _context.Context
	ApiService ClusterLinkingV3Api
	clusterId string
	linkName string
	validateOnly *bool
	alterMirrorsRequestData *AlterMirrorsRequestData
}

// To validate if the link can be created or not, but not to create it. Default: false
func (r ApiUpdateKafkaV3MirrorTopicsPauseRequest) ValidateOnly(validateOnly bool) ApiUpdateKafkaV3MirrorTopicsPauseRequest {
	r.validateOnly = &validateOnly
	return r
}
// Name of the topics to apply the changes
func (r ApiUpdateKafkaV3MirrorTopicsPauseRequest) AlterMirrorsRequestData(alterMirrorsRequestData AlterMirrorsRequestData) ApiUpdateKafkaV3MirrorTopicsPauseRequest {
	r.alterMirrorsRequestData = &alterMirrorsRequestData
	return r
}

func (r ApiUpdateKafkaV3MirrorTopicsPauseRequest) Execute() (AlterMirrorStatusResponseDataList, *_nethttp.Response, error) {
	return r.ApiService.UpdateKafkaV3MirrorTopicsPauseExecute(r)
}

/*
UpdateKafkaV3MirrorTopicsPause Pause the mirror topics

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId The Kafka cluster ID.
 @param linkName The link name
 @return ApiUpdateKafkaV3MirrorTopicsPauseRequest
*/
func (a *ClusterLinkingV3ApiService) UpdateKafkaV3MirrorTopicsPause(ctx _context.Context, clusterId string, linkName string) ApiUpdateKafkaV3MirrorTopicsPauseRequest {
	return ApiUpdateKafkaV3MirrorTopicsPauseRequest{
		ApiService: a,
		ctx: ctx,
		clusterId: clusterId,
		linkName: linkName,
	}
}

// Execute executes the request
//  @return AlterMirrorStatusResponseDataList
func (a *ClusterLinkingV3ApiService) UpdateKafkaV3MirrorTopicsPauseExecute(r ApiUpdateKafkaV3MirrorTopicsPauseRequest) (AlterMirrorStatusResponseDataList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AlterMirrorStatusResponseDataList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterLinkingV3ApiService.UpdateKafkaV3MirrorTopicsPause")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafka/v3/clusters/{cluster_id}/links/{link_name}/mirrors:pause"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(r.clusterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"link_name"+"}", _neturl.PathEscape(parameterToString(r.linkName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.validateOnly != nil {
		localVarQueryParams.Add("validate_only", parameterToString(*r.validateOnly, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.alterMirrorsRequestData
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateKafkaV3MirrorTopicsPromoteRequest struct {
	ctx _context.Context
	ApiService ClusterLinkingV3Api
	clusterId string
	linkName string
	validateOnly *bool
	alterMirrorsRequestData *AlterMirrorsRequestData
}

// To validate if the link can be created or not, but not to create it. Default: false
func (r ApiUpdateKafkaV3MirrorTopicsPromoteRequest) ValidateOnly(validateOnly bool) ApiUpdateKafkaV3MirrorTopicsPromoteRequest {
	r.validateOnly = &validateOnly
	return r
}
// Name of the topics to apply the changes
func (r ApiUpdateKafkaV3MirrorTopicsPromoteRequest) AlterMirrorsRequestData(alterMirrorsRequestData AlterMirrorsRequestData) ApiUpdateKafkaV3MirrorTopicsPromoteRequest {
	r.alterMirrorsRequestData = &alterMirrorsRequestData
	return r
}

func (r ApiUpdateKafkaV3MirrorTopicsPromoteRequest) Execute() (AlterMirrorStatusResponseDataList, *_nethttp.Response, error) {
	return r.ApiService.UpdateKafkaV3MirrorTopicsPromoteExecute(r)
}

/*
UpdateKafkaV3MirrorTopicsPromote Promote the mirror topics

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId The Kafka cluster ID.
 @param linkName The link name
 @return ApiUpdateKafkaV3MirrorTopicsPromoteRequest
*/
func (a *ClusterLinkingV3ApiService) UpdateKafkaV3MirrorTopicsPromote(ctx _context.Context, clusterId string, linkName string) ApiUpdateKafkaV3MirrorTopicsPromoteRequest {
	return ApiUpdateKafkaV3MirrorTopicsPromoteRequest{
		ApiService: a,
		ctx: ctx,
		clusterId: clusterId,
		linkName: linkName,
	}
}

// Execute executes the request
//  @return AlterMirrorStatusResponseDataList
func (a *ClusterLinkingV3ApiService) UpdateKafkaV3MirrorTopicsPromoteExecute(r ApiUpdateKafkaV3MirrorTopicsPromoteRequest) (AlterMirrorStatusResponseDataList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AlterMirrorStatusResponseDataList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterLinkingV3ApiService.UpdateKafkaV3MirrorTopicsPromote")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafka/v3/clusters/{cluster_id}/links/{link_name}/mirrors:promote"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(r.clusterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"link_name"+"}", _neturl.PathEscape(parameterToString(r.linkName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.validateOnly != nil {
		localVarQueryParams.Add("validate_only", parameterToString(*r.validateOnly, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.alterMirrorsRequestData
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateKafkaV3MirrorTopicsResumeRequest struct {
	ctx _context.Context
	ApiService ClusterLinkingV3Api
	clusterId string
	linkName string
	validateOnly *bool
	alterMirrorsRequestData *AlterMirrorsRequestData
}

// To validate if the link can be created or not, but not to create it. Default: false
func (r ApiUpdateKafkaV3MirrorTopicsResumeRequest) ValidateOnly(validateOnly bool) ApiUpdateKafkaV3MirrorTopicsResumeRequest {
	r.validateOnly = &validateOnly
	return r
}
// Name of the topics to apply the changes
func (r ApiUpdateKafkaV3MirrorTopicsResumeRequest) AlterMirrorsRequestData(alterMirrorsRequestData AlterMirrorsRequestData) ApiUpdateKafkaV3MirrorTopicsResumeRequest {
	r.alterMirrorsRequestData = &alterMirrorsRequestData
	return r
}

func (r ApiUpdateKafkaV3MirrorTopicsResumeRequest) Execute() (AlterMirrorStatusResponseDataList, *_nethttp.Response, error) {
	return r.ApiService.UpdateKafkaV3MirrorTopicsResumeExecute(r)
}

/*
UpdateKafkaV3MirrorTopicsResume Resume the mirror topics

[![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId The Kafka cluster ID.
 @param linkName The link name
 @return ApiUpdateKafkaV3MirrorTopicsResumeRequest
*/
func (a *ClusterLinkingV3ApiService) UpdateKafkaV3MirrorTopicsResume(ctx _context.Context, clusterId string, linkName string) ApiUpdateKafkaV3MirrorTopicsResumeRequest {
	return ApiUpdateKafkaV3MirrorTopicsResumeRequest{
		ApiService: a,
		ctx: ctx,
		clusterId: clusterId,
		linkName: linkName,
	}
}

// Execute executes the request
//  @return AlterMirrorStatusResponseDataList
func (a *ClusterLinkingV3ApiService) UpdateKafkaV3MirrorTopicsResumeExecute(r ApiUpdateKafkaV3MirrorTopicsResumeRequest) (AlterMirrorStatusResponseDataList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AlterMirrorStatusResponseDataList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterLinkingV3ApiService.UpdateKafkaV3MirrorTopicsResume")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafka/v3/clusters/{cluster_id}/links/{link_name}/mirrors:resume"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(r.clusterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"link_name"+"}", _neturl.PathEscape(parameterToString(r.linkName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.validateOnly != nil {
		localVarQueryParams.Add("validate_only", parameterToString(*r.validateOnly, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.alterMirrorsRequestData
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
