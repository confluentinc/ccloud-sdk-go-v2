// Code generated by mocker. DO NOT EDIT.
// github.com/travisjeffery/mocker
// Source: api_topic_v3.go

package mock

import (
	context "context"
	net_http "net/http"
	sync "sync"

	github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3 "github.com/confluentinc/ccloud-sdk-go-v2/kafkarest/v3"
)

// TopicV3Api is a mock of TopicV3Api interface
type TopicV3Api struct {
	lockCreateKafkaTopic sync.Mutex
	CreateKafkaTopicFunc func(ctx context.Context, clusterId string) github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.ApiCreateKafkaTopicRequest

	lockCreateKafkaTopicExecute sync.Mutex
	CreateKafkaTopicExecuteFunc func(r github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.ApiCreateKafkaTopicRequest) (github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.TopicData, *net_http.Response, error)

	lockDeleteKafkaTopic sync.Mutex
	DeleteKafkaTopicFunc func(ctx context.Context, clusterId, topicName string) github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.ApiDeleteKafkaTopicRequest

	lockDeleteKafkaTopicExecute sync.Mutex
	DeleteKafkaTopicExecuteFunc func(r github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.ApiDeleteKafkaTopicRequest) (*net_http.Response, error)

	lockGetKafkaTopic sync.Mutex
	GetKafkaTopicFunc func(ctx context.Context, clusterId, topicName string) github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.ApiGetKafkaTopicRequest

	lockGetKafkaTopicExecute sync.Mutex
	GetKafkaTopicExecuteFunc func(r github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.ApiGetKafkaTopicRequest) (github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.TopicData, *net_http.Response, error)

	lockListKafkaTopics sync.Mutex
	ListKafkaTopicsFunc func(ctx context.Context, clusterId string) github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.ApiListKafkaTopicsRequest

	lockListKafkaTopicsExecute sync.Mutex
	ListKafkaTopicsExecuteFunc func(r github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.ApiListKafkaTopicsRequest) (github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.TopicDataList, *net_http.Response, error)

	calls struct {
		CreateKafkaTopic []struct {
			Ctx       context.Context
			ClusterId string
		}
		CreateKafkaTopicExecute []struct {
			R github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.ApiCreateKafkaTopicRequest
		}
		DeleteKafkaTopic []struct {
			Ctx       context.Context
			ClusterId string
			TopicName string
		}
		DeleteKafkaTopicExecute []struct {
			R github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.ApiDeleteKafkaTopicRequest
		}
		GetKafkaTopic []struct {
			Ctx       context.Context
			ClusterId string
			TopicName string
		}
		GetKafkaTopicExecute []struct {
			R github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.ApiGetKafkaTopicRequest
		}
		ListKafkaTopics []struct {
			Ctx       context.Context
			ClusterId string
		}
		ListKafkaTopicsExecute []struct {
			R github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.ApiListKafkaTopicsRequest
		}
	}
}

// CreateKafkaTopic mocks base method by wrapping the associated func.
func (m *TopicV3Api) CreateKafkaTopic(ctx context.Context, clusterId string) github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.ApiCreateKafkaTopicRequest {
	m.lockCreateKafkaTopic.Lock()
	defer m.lockCreateKafkaTopic.Unlock()

	if m.CreateKafkaTopicFunc == nil {
		panic("mocker: TopicV3Api.CreateKafkaTopicFunc is nil but TopicV3Api.CreateKafkaTopic was called.")
	}

	call := struct {
		Ctx       context.Context
		ClusterId string
	}{
		Ctx:       ctx,
		ClusterId: clusterId,
	}

	m.calls.CreateKafkaTopic = append(m.calls.CreateKafkaTopic, call)

	return m.CreateKafkaTopicFunc(ctx, clusterId)
}

// CreateKafkaTopicCalled returns true if CreateKafkaTopic was called at least once.
func (m *TopicV3Api) CreateKafkaTopicCalled() bool {
	m.lockCreateKafkaTopic.Lock()
	defer m.lockCreateKafkaTopic.Unlock()

	return len(m.calls.CreateKafkaTopic) > 0
}

// CreateKafkaTopicCalls returns the calls made to CreateKafkaTopic.
func (m *TopicV3Api) CreateKafkaTopicCalls() []struct {
	Ctx       context.Context
	ClusterId string
} {
	m.lockCreateKafkaTopic.Lock()
	defer m.lockCreateKafkaTopic.Unlock()

	return m.calls.CreateKafkaTopic
}

// CreateKafkaTopicExecute mocks base method by wrapping the associated func.
func (m *TopicV3Api) CreateKafkaTopicExecute(r github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.ApiCreateKafkaTopicRequest) (github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.TopicData, *net_http.Response, error) {
	m.lockCreateKafkaTopicExecute.Lock()
	defer m.lockCreateKafkaTopicExecute.Unlock()

	if m.CreateKafkaTopicExecuteFunc == nil {
		panic("mocker: TopicV3Api.CreateKafkaTopicExecuteFunc is nil but TopicV3Api.CreateKafkaTopicExecute was called.")
	}

	call := struct {
		R github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.ApiCreateKafkaTopicRequest
	}{
		R: r,
	}

	m.calls.CreateKafkaTopicExecute = append(m.calls.CreateKafkaTopicExecute, call)

	return m.CreateKafkaTopicExecuteFunc(r)
}

// CreateKafkaTopicExecuteCalled returns true if CreateKafkaTopicExecute was called at least once.
func (m *TopicV3Api) CreateKafkaTopicExecuteCalled() bool {
	m.lockCreateKafkaTopicExecute.Lock()
	defer m.lockCreateKafkaTopicExecute.Unlock()

	return len(m.calls.CreateKafkaTopicExecute) > 0
}

// CreateKafkaTopicExecuteCalls returns the calls made to CreateKafkaTopicExecute.
func (m *TopicV3Api) CreateKafkaTopicExecuteCalls() []struct {
	R github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.ApiCreateKafkaTopicRequest
} {
	m.lockCreateKafkaTopicExecute.Lock()
	defer m.lockCreateKafkaTopicExecute.Unlock()

	return m.calls.CreateKafkaTopicExecute
}

// DeleteKafkaTopic mocks base method by wrapping the associated func.
func (m *TopicV3Api) DeleteKafkaTopic(ctx context.Context, clusterId, topicName string) github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.ApiDeleteKafkaTopicRequest {
	m.lockDeleteKafkaTopic.Lock()
	defer m.lockDeleteKafkaTopic.Unlock()

	if m.DeleteKafkaTopicFunc == nil {
		panic("mocker: TopicV3Api.DeleteKafkaTopicFunc is nil but TopicV3Api.DeleteKafkaTopic was called.")
	}

	call := struct {
		Ctx       context.Context
		ClusterId string
		TopicName string
	}{
		Ctx:       ctx,
		ClusterId: clusterId,
		TopicName: topicName,
	}

	m.calls.DeleteKafkaTopic = append(m.calls.DeleteKafkaTopic, call)

	return m.DeleteKafkaTopicFunc(ctx, clusterId, topicName)
}

// DeleteKafkaTopicCalled returns true if DeleteKafkaTopic was called at least once.
func (m *TopicV3Api) DeleteKafkaTopicCalled() bool {
	m.lockDeleteKafkaTopic.Lock()
	defer m.lockDeleteKafkaTopic.Unlock()

	return len(m.calls.DeleteKafkaTopic) > 0
}

// DeleteKafkaTopicCalls returns the calls made to DeleteKafkaTopic.
func (m *TopicV3Api) DeleteKafkaTopicCalls() []struct {
	Ctx       context.Context
	ClusterId string
	TopicName string
} {
	m.lockDeleteKafkaTopic.Lock()
	defer m.lockDeleteKafkaTopic.Unlock()

	return m.calls.DeleteKafkaTopic
}

// DeleteKafkaTopicExecute mocks base method by wrapping the associated func.
func (m *TopicV3Api) DeleteKafkaTopicExecute(r github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.ApiDeleteKafkaTopicRequest) (*net_http.Response, error) {
	m.lockDeleteKafkaTopicExecute.Lock()
	defer m.lockDeleteKafkaTopicExecute.Unlock()

	if m.DeleteKafkaTopicExecuteFunc == nil {
		panic("mocker: TopicV3Api.DeleteKafkaTopicExecuteFunc is nil but TopicV3Api.DeleteKafkaTopicExecute was called.")
	}

	call := struct {
		R github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.ApiDeleteKafkaTopicRequest
	}{
		R: r,
	}

	m.calls.DeleteKafkaTopicExecute = append(m.calls.DeleteKafkaTopicExecute, call)

	return m.DeleteKafkaTopicExecuteFunc(r)
}

// DeleteKafkaTopicExecuteCalled returns true if DeleteKafkaTopicExecute was called at least once.
func (m *TopicV3Api) DeleteKafkaTopicExecuteCalled() bool {
	m.lockDeleteKafkaTopicExecute.Lock()
	defer m.lockDeleteKafkaTopicExecute.Unlock()

	return len(m.calls.DeleteKafkaTopicExecute) > 0
}

// DeleteKafkaTopicExecuteCalls returns the calls made to DeleteKafkaTopicExecute.
func (m *TopicV3Api) DeleteKafkaTopicExecuteCalls() []struct {
	R github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.ApiDeleteKafkaTopicRequest
} {
	m.lockDeleteKafkaTopicExecute.Lock()
	defer m.lockDeleteKafkaTopicExecute.Unlock()

	return m.calls.DeleteKafkaTopicExecute
}

// GetKafkaTopic mocks base method by wrapping the associated func.
func (m *TopicV3Api) GetKafkaTopic(ctx context.Context, clusterId, topicName string) github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.ApiGetKafkaTopicRequest {
	m.lockGetKafkaTopic.Lock()
	defer m.lockGetKafkaTopic.Unlock()

	if m.GetKafkaTopicFunc == nil {
		panic("mocker: TopicV3Api.GetKafkaTopicFunc is nil but TopicV3Api.GetKafkaTopic was called.")
	}

	call := struct {
		Ctx       context.Context
		ClusterId string
		TopicName string
	}{
		Ctx:       ctx,
		ClusterId: clusterId,
		TopicName: topicName,
	}

	m.calls.GetKafkaTopic = append(m.calls.GetKafkaTopic, call)

	return m.GetKafkaTopicFunc(ctx, clusterId, topicName)
}

// GetKafkaTopicCalled returns true if GetKafkaTopic was called at least once.
func (m *TopicV3Api) GetKafkaTopicCalled() bool {
	m.lockGetKafkaTopic.Lock()
	defer m.lockGetKafkaTopic.Unlock()

	return len(m.calls.GetKafkaTopic) > 0
}

// GetKafkaTopicCalls returns the calls made to GetKafkaTopic.
func (m *TopicV3Api) GetKafkaTopicCalls() []struct {
	Ctx       context.Context
	ClusterId string
	TopicName string
} {
	m.lockGetKafkaTopic.Lock()
	defer m.lockGetKafkaTopic.Unlock()

	return m.calls.GetKafkaTopic
}

// GetKafkaTopicExecute mocks base method by wrapping the associated func.
func (m *TopicV3Api) GetKafkaTopicExecute(r github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.ApiGetKafkaTopicRequest) (github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.TopicData, *net_http.Response, error) {
	m.lockGetKafkaTopicExecute.Lock()
	defer m.lockGetKafkaTopicExecute.Unlock()

	if m.GetKafkaTopicExecuteFunc == nil {
		panic("mocker: TopicV3Api.GetKafkaTopicExecuteFunc is nil but TopicV3Api.GetKafkaTopicExecute was called.")
	}

	call := struct {
		R github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.ApiGetKafkaTopicRequest
	}{
		R: r,
	}

	m.calls.GetKafkaTopicExecute = append(m.calls.GetKafkaTopicExecute, call)

	return m.GetKafkaTopicExecuteFunc(r)
}

// GetKafkaTopicExecuteCalled returns true if GetKafkaTopicExecute was called at least once.
func (m *TopicV3Api) GetKafkaTopicExecuteCalled() bool {
	m.lockGetKafkaTopicExecute.Lock()
	defer m.lockGetKafkaTopicExecute.Unlock()

	return len(m.calls.GetKafkaTopicExecute) > 0
}

// GetKafkaTopicExecuteCalls returns the calls made to GetKafkaTopicExecute.
func (m *TopicV3Api) GetKafkaTopicExecuteCalls() []struct {
	R github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.ApiGetKafkaTopicRequest
} {
	m.lockGetKafkaTopicExecute.Lock()
	defer m.lockGetKafkaTopicExecute.Unlock()

	return m.calls.GetKafkaTopicExecute
}

// ListKafkaTopics mocks base method by wrapping the associated func.
func (m *TopicV3Api) ListKafkaTopics(ctx context.Context, clusterId string) github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.ApiListKafkaTopicsRequest {
	m.lockListKafkaTopics.Lock()
	defer m.lockListKafkaTopics.Unlock()

	if m.ListKafkaTopicsFunc == nil {
		panic("mocker: TopicV3Api.ListKafkaTopicsFunc is nil but TopicV3Api.ListKafkaTopics was called.")
	}

	call := struct {
		Ctx       context.Context
		ClusterId string
	}{
		Ctx:       ctx,
		ClusterId: clusterId,
	}

	m.calls.ListKafkaTopics = append(m.calls.ListKafkaTopics, call)

	return m.ListKafkaTopicsFunc(ctx, clusterId)
}

// ListKafkaTopicsCalled returns true if ListKafkaTopics was called at least once.
func (m *TopicV3Api) ListKafkaTopicsCalled() bool {
	m.lockListKafkaTopics.Lock()
	defer m.lockListKafkaTopics.Unlock()

	return len(m.calls.ListKafkaTopics) > 0
}

// ListKafkaTopicsCalls returns the calls made to ListKafkaTopics.
func (m *TopicV3Api) ListKafkaTopicsCalls() []struct {
	Ctx       context.Context
	ClusterId string
} {
	m.lockListKafkaTopics.Lock()
	defer m.lockListKafkaTopics.Unlock()

	return m.calls.ListKafkaTopics
}

// ListKafkaTopicsExecute mocks base method by wrapping the associated func.
func (m *TopicV3Api) ListKafkaTopicsExecute(r github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.ApiListKafkaTopicsRequest) (github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.TopicDataList, *net_http.Response, error) {
	m.lockListKafkaTopicsExecute.Lock()
	defer m.lockListKafkaTopicsExecute.Unlock()

	if m.ListKafkaTopicsExecuteFunc == nil {
		panic("mocker: TopicV3Api.ListKafkaTopicsExecuteFunc is nil but TopicV3Api.ListKafkaTopicsExecute was called.")
	}

	call := struct {
		R github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.ApiListKafkaTopicsRequest
	}{
		R: r,
	}

	m.calls.ListKafkaTopicsExecute = append(m.calls.ListKafkaTopicsExecute, call)

	return m.ListKafkaTopicsExecuteFunc(r)
}

// ListKafkaTopicsExecuteCalled returns true if ListKafkaTopicsExecute was called at least once.
func (m *TopicV3Api) ListKafkaTopicsExecuteCalled() bool {
	m.lockListKafkaTopicsExecute.Lock()
	defer m.lockListKafkaTopicsExecute.Unlock()

	return len(m.calls.ListKafkaTopicsExecute) > 0
}

// ListKafkaTopicsExecuteCalls returns the calls made to ListKafkaTopicsExecute.
func (m *TopicV3Api) ListKafkaTopicsExecuteCalls() []struct {
	R github_com_confluentinc_ccloud_sdk_go_v2_kafkarest_v3.ApiListKafkaTopicsRequest
} {
	m.lockListKafkaTopicsExecute.Lock()
	defer m.lockListKafkaTopicsExecute.Unlock()

	return m.calls.ListKafkaTopicsExecute
}

// Reset resets the calls made to the mocked methods.
func (m *TopicV3Api) Reset() {
	m.lockCreateKafkaTopic.Lock()
	m.calls.CreateKafkaTopic = nil
	m.lockCreateKafkaTopic.Unlock()
	m.lockCreateKafkaTopicExecute.Lock()
	m.calls.CreateKafkaTopicExecute = nil
	m.lockCreateKafkaTopicExecute.Unlock()
	m.lockDeleteKafkaTopic.Lock()
	m.calls.DeleteKafkaTopic = nil
	m.lockDeleteKafkaTopic.Unlock()
	m.lockDeleteKafkaTopicExecute.Lock()
	m.calls.DeleteKafkaTopicExecute = nil
	m.lockDeleteKafkaTopicExecute.Unlock()
	m.lockGetKafkaTopic.Lock()
	m.calls.GetKafkaTopic = nil
	m.lockGetKafkaTopic.Unlock()
	m.lockGetKafkaTopicExecute.Lock()
	m.calls.GetKafkaTopicExecute = nil
	m.lockGetKafkaTopicExecute.Unlock()
	m.lockListKafkaTopics.Lock()
	m.calls.ListKafkaTopics = nil
	m.lockListKafkaTopics.Unlock()
	m.lockListKafkaTopicsExecute.Lock()
	m.calls.ListKafkaTopicsExecute = nil
	m.lockListKafkaTopicsExecute.Unlock()
}
